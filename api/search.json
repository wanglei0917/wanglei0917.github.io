[{"id":"647ebdc553edc1b455b5763958a586e8","title":"HandsonTable","content":" \n    😋😋😋😋😋😋😋😋😋😋😋😋😋😋😋\n\n\n\n\n \n    😋😋😋😋😋😋😋😋😋😋😋😋😋😋😋\n\n\n\n\n \n    😋😋😋😋😋😋😋😋😋😋😋😋😋😋😋\n\n\n\n\n \n    😋😋😋😋😋😋😋😋😋😋😋😋😋😋😋\n\n\n\n\n \n    😋😋😋😋😋😋😋😋😋😋😋😋😋😋😋\n\n\n\n\n \n    😋😋😋😋😋😋😋😋😋😋😋😋😋😋😋\n\n\n\n\n \n    😋😋😋😋😋😋😋😋😋😋😋😋😋😋😋\n\n\n\n\n \n    😋😋😋😋😋😋😋😋😋😋😋😋😋😋😋\n\n\n\n\n \n    😋😋😋😋😋😋😋😋😋😋😋😋😋😋😋\n\n\n\n\n \n    😋😋😋😋😋😋😋😋😋😋😋😋😋😋😋\n\n\n\n\n快捷链接\n    Handsontable-Core \n    Handsontable-Option \n    Handsontable-Hooks \n    Handsontable-Plugin篇-MergeCells \n    Handsontable-Plugin篇-UndoRedo \n\n","slug":"HandsonTable","date":"2022-05-13T02:53:15.000Z","categories_index":"","tags_index":"HandsonTable","author_index":"王磊磊"},{"id":"195947292051bf18534efeda0536746f","title":"使用Hexo从0到1搭建并部署自己的博客","content":"安装 hexonpm install hexo-cli -g\n\n初始化博客hexo init &lt;your blog name>\ncd &lt;your blog name>\nnpm install\nnpm run server\n\n\n\n  这里就已经可以看到最基础的效果,开始愉快的写作吧,更多关于hexo的使用技巧可以查看官网\n  Hexo官网\n\n\n部署到 github由于没有服务器,我是使用 GitHub Pages来部署的, 也可以使用国内的Gitee Pages或者其他的可以部署静态页面的产品\n\n首先创建一个与用户名同名的仓库,只有这样,等部署完成的时候才可以使用 xxxxx.github.io 直接访问,由于我这里已经创建过了, 所以报错\n\n\n\n进入仓库设置,添加 ssh 公钥,具体过程可自行百度,这样做是因为部署的时候可以直接使用私钥将写好的东西推送至仓库\n\n\n\n安装hexo-deployer-git\n\nnpm install hexo-deployer-git --save\n\n\n修改项目根目录下_config.yml文件\ndeploy:\n  type: git\n  repo: https:&#x2F;&#x2F;github.com&#x2F;yourUserName&#x2F;yourUserName.github.io.git\n  branch: main\n\n\n\n\n\n\n\n提示\nrepo指定仓库地址,branch指定部署分支,可以添加多个\n\n\n\n推送\n\n使用hexo deploy或者npm run deploy即可将生成的静态文件推送至 github 仓库\n至此, 就可以使用 xxxx.github.io 访问到你的博客了\n自定义域名\n在阿里云或者腾讯云或者别的可以买域名的地方买一个域名,这里以腾讯云为例\n\n添加 DNS 解析\n\n\n\n\n\n\n\n提示\n这里 CNAME 的记录值设置为你之前的访问地址\nA 记录的记录值可以通过这种方式拿到\n\n\n\n\n在你的根目录source下添加一个CNAME的文件, 注意这个文件不带后缀,内容写你买的域名即可\n\n在github仓库设置中设置自定义域名\n\n\n\n\n稍等一会,DNS 解析需要一定时间, 一般十分钟, 然后就可以通过你买的域名访问到你的博客啦\n\n使用coding部署因为网络原因 github 有时可能无法访问,所以这是部署的第二套方案\n\n在腾讯云控制台 对象存储中, 创建一个存储桶\n\n\n进入桶设置打开静态页面开关\n\n开启之后就可以访问了,但是是没有任何文件的\n\n在控制台搜索访问管理,创建一个访问密钥\n\n后续使用coding中的自动构建时, 用密钥就可以将生成的文件上传至存储桶内\n\n在 coding 中新建一个项目\n\n选择持续集成中的构建计划\n\n\n自定义你的构建过程\n\n\n\n\n\n\n\n\n注意\n注意: 这里的仓库是你的源代码仓库, 别和你之前在 github 上的仓库搞混了,, 也可以使用同一个,但是这样的话就需要你重新创建一个源代码分支, 因为之前在 guthub 上通过 hexo d 命令推送上去的是生成的文件,使用新分支管路源代码\n\n\n\n贴出我自己的过程\npipeline &#123;\n  agent any\n  stages &#123;\n    stage('检出') &#123;\n      steps &#123;\n        checkout([\n          $class: 'GitSCM',\n          branches: [[name: GIT_BUILD_REF]],\n          userRemoteConfigs: [[\n            url: GIT_REPO_URL,\n            credentialsId: CREDENTIALS_ID\n          ]]\n        ])\n      &#125;\n    &#125;\n    stage('升级Node版本') &#123;\n      steps &#123;\n        sh 'rm -rf /usr/lib/node_modules/npm/'\n        dir ('/root/.cache/downloads') &#123;\n          sh 'wget -nc \"https://coding-public-generic.pkg.coding.net/public/downloads/node-linux-x64.tar.xz?version=v16.13.0\" -O node-v16.13.0-linux-x64.tar.xz | true'\n          sh 'tar -xf node-v16.13.0-linux-x64.tar.xz -C /usr --strip-components 1'\n          // sh 'wget -nc \"https://coding-public-generic.pkg.coding.net/public/downloads/node-linux-x64.tar.xz?version=v14.18.2\" -O node-v14.18.2-linux-x64.tar.xz | true'\n          // sh 'tar -xf node-v14.18.2-linux-x64.tar.xz -C /usr --strip-components 1'\n          // 更多版本：v12.22.7、v17.2.0\n        &#125;\n        sh 'node -v'\n      &#125;\n    &#125;\n    stage('构建') &#123;\n      steps &#123;\n        echo '开始构建'\n        sh 'npm install -g hexo-cli'\n        sh 'npm install'\n        sh 'npm run build'\n      &#125;\n    &#125;\n    stage('部署') &#123;\n      steps &#123;\n        echo '开始部署'\n        sh \"coscmd config -a $&#123;env.COS_SECRET_ID&#125; -s $&#123;env.COS_SECRET_KEY&#125; -b $&#123;env.COS_BUCKET_NAME&#125; -r $&#123;env.COS_BUCKET_REGION&#125;\"\n        sh 'coscmd upload -r public/ /'\n      &#125;\n    &#125;\n  &#125;\n  post &#123;\n    success &#123;\n      echo '\\'部署完成\\''\n    &#125;\n  &#125;\n  &#125;\n\n\n\n\n\n\n\n提示\n39 40 行就是将生成的 public 文件夹的内容上传至存储桶, 这里的环境变量自行配置\n\n\n\n至此, 就可以使用在存储桶中开启的静态页面地址访问到你的博客啦\n\n在存储桶设置 -&gt; 域名与传输管理中可自定义域名,但是域名需要备案\n\n\n\n\n\n\n\n\n提示\n使用coding部署的话,源代码提交即可自动构建,使用github pages的话,需要每次写完hexo d手动构建一下,如何省去这一步呢?\n\n首先在coding新建一个自定义构建过程\n\n编写 JenkinsFile 文件, 因为hexo d命令实际上就是先build,然后再push到你的存储库, 我们可以拿到之前使用ssh生成的私钥文件,放在源代码里,或者通过 shell 写入到构建过程中的根目录中,再配置 git 提交时的用户名及邮箱\n\n然后就可以在每次提交源代码的时候自动构建并推送至 github 与 coding\n\n\n\n\n如有错误请指出\n","slug":"搭建博客","date":"2022-04-03T11:12:24.000Z","categories_index":"","tags_index":"Blog","author_index":"王磊磊"},{"id":"f7d77bfe1e6b724bbb02972e6eb815ab","title":"常见面试题汇总","content":"HTML什么是盒子模型？\n\n\n\n\n\n\n\n\n在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容(content)，元素的内边距(padding)，元素的边框(border)，元素的外边距(margin)四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4 个部分一起构成了 css 中元素的盒模型。\n\n标准盒模型的width和height范围只包含了content –&gt; content-box\nIE 盒模型的width和height范围包含了border,padding和content –&gt; border-box\n\n\n\n&lt;image&gt; 标签上title属性与alt属性的区别是什么？\n\n\n\n\n\n\n\n\n**alt**属性是为了给那些不能看到你文档中图像的浏览者提供文字说明的。且长度必须少于 100 个英文字符或者用户必须保证替换文字尽可能的短。\n这包括那些使用本来就不支持图像显示或者图像显示被关闭的浏览器的用户，视觉障碍的用户和使用屏幕阅读器的用户等。\n**title**属性为设置该属性的元素提供建议性的信息。使用title属性提供非本质的额外信息。title 属性可以实现鼠标悬停提示的效果。\n请写出至少 5 个 HTML5 新增的标签，并说明其语义和应用场景？\n\n\n\n\n\n\n\n\n**&lt;header&gt;**：主要用于定义内容的介绍展示区域，描述了文档的头部区域，比如定义文章的头；\n**&lt;nav&gt;**：定义导航链接的部分；\n**&lt;section&gt;**：定义了文档中的节，比如章节、页眉、页脚或文档中的其他部分；\n**&lt;article&gt;**：定义独立的内容；\n**&lt;aside&gt;**：定义页面主区域之外的内容，比如侧边栏；\n**&lt;figcaption&gt;**：定义&lt;figure&gt;元素的标题，一般被放置在&lt;figure&gt;元素内的第一个或最后一个位置处；\n** &lt;figure&gt;**：定义独立的流内容，比如图形、图标、照片、代码等；\n**&lt;footer&gt;**：定义文档的底部区域，描述文档的页脚，比如作者、著作权信息、联系方式等；\n简单描述 DOCTYPE 的作用？严格模式与混杂模式如何区分？它们有何意义？\n\n\n\n\n\n\n\n\nDOCTYPE 的作用：DOCTYPE 声明在文档的最前面， 位于根元素 HTML 的起始标签之前 ，这样一来，在浏览器解析 HTML 文档正文之前就可以确定当前文档的类型，以决定其需要采用的渲染模式，不同的渲染模式会影响到浏览器对于 CSS 代码甚至 JavaScript 脚本的解析。\n严格模式与混杂模式：严格模式的排版和 JS 运作模式是以浏览器支持的最高标准运行；而在混杂模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作；\n当 DOCTYPE 不存在或者格式不正确时，会导致文档以混杂模式呈现。\nCSS常见的 CSS 布局有哪些\n\n\n\n\n\n\n\n\n流式布局\n弹性布局 Flex\n浮动布局\n定位布局\n列举几个清除浮动的方式\n\n\n\n\n\n\n\n\n\n使用 clear属性\n\n&lt;div style=\"clear:both\">&lt;/div>\n\n\n设置父元素的样式\n\n.father &#123;\n  overflow: hidden | auto;\n&#125;\n.father &#123;\n  display: table;\n&#125;\n\n\n使用after伪元素\n\n列举几种隐藏元素的方法\n\n\n\n\n\n\n\n\n\nvisibility: hidden 隐藏元素, 但元素所占据的空间依然存在\nopacity: 0 设置元素透明度为 0,效果与 visibility 类似\ndisplay: none 设置元素不可见, 此时不占据文档空间\n添加hidden属性 H5 新增属性, 效果与 display: none类似\nposition: absolute 通过绝对定位移出可是区域\ntransform: scale(0) 将元素缩放为 0\n\nlink 和@import 的区别\n\n\n\n\n\n\n\n\n两者都是引入 css 的方式,\n\nlink是 html 标签, 除了可以加载 css 外, 还可以加载例如 icon\nlink引入 css 时, 在页面载入时同时加载, @import则是等网页载入完成后加载\nlink是 html 标签,不存在让兼容性问题, @import是 css2.1 中提出的, 一些低版本的浏览器可能不支持\nlink 支持 js 控制 dom 去改变样式, @import不支持\n\n伪元素与伪类的区别和作用?\n\n\n\n\n\n\n\n\n\n伪元素: 在内容元素的前后额外插入的元素或者样式,但是这些元素实际上并不会在文档中生成,他们只在外部显示可见,但不会在文档中找到他们, 因此被称为 伪元素\n伪类: 将特殊的效果添加到特定的选择器上, 它是已有元素上添加类别的, 不会产生新的元素\n\n总结: 伪类是通过在元素选择器上加入伪类改变元素状态, 而伪元素是通过对元素的操作进行对元素的该变\ncalc,support,media 各自的含义及用法\n\n\n\n\n\n\n\n\n@support 主要用于检测浏览器是否支持某一个 CSS 属性,其实就是条件判断\n@media 媒体查询, 可以针对不同的媒体类型定义不同的样式\ncalc() 用于动态计算值\n如何实现水平居中, 垂直剧中\n\n\n\n\n\n\n\n\n\n水平居中\ntext-align: center\nmargin: 0 auto\nposition: absolute;left: 50%;transform: translateY(-50%)\ndisplay: flex;justify-content: center\n\n\n垂直居中\nline-height: 盒子高度\ndisplay: table; vertical-align: middle\nposition: absolute; top: 50%;transform: translateX(-50%)\ndisplay: flex;align-item: center\n\n\n\nrem, em, vw/vh, px 各代表什么?\n\n\n\n\n\n\n\n\nrem根元素的font-size\nem 父元素的font-size\nvw/vh 视窗的宽度和高度\npx 像素大小,相对于当前显示器屏幕分辨率\n如何画一条 0.5px 的线\n\n\n\n\n\n\n\n\nheight: 1px;\ntransform: scale(0.5);\n画一个三角形\n\n\n\n\n\n\n\n\n&lt;div class=\"box\">&lt;/div>\n&lt;style>\n  .box &#123;\n    width: 0;\n    height: 0;\n    border: 10px solid transparent;\n    border-right-color: #000;\n    transfrom: retate(90deg);\n  &#125;\n&lt;/style>\nCSS3 中有那些新特性\n\n\n\n\n\n\n\n\n\n新增各种 css 选择器(:not(.input): 所有class不是input的节点)\n圆角(border-radius)\n过渡(transfrom)\n文字特效(text-shadow)\n\nJSlet const var 的区别\n\n\n\n\n\n\n\n\n\nvar 声明的变量是全局变量, 使用var声明的变量会挂载在window上,而let和const则不会\nvar声明的变量存在变量提升\nlet const 声明的变量会形成块级作用域\n同一作用域下使用let或者const不能声明同名变量\nlet const 声明的变量存在暂存死区, 即在声明前使用变量会报错\nconst声明的变量不可以修改,引用类型变量可以修改其内部成员\nlet var声明的时候可以不声明初始值,const必须指定初始值\n\nJS 中有哪几种数据类型, 区别是什么\n\n\n\n\n\n\n\n\n\n原始数据类型\nundefined null boolean number string\n\n引用数据类型\nobject\n\n\n原始数据类型在栈中\n引用数据类型在堆中, 因为引用数据类型大小不固定,如果存储在栈中会影响程序运行额性能,所以在栈中只存放了一个地址, 指向堆中的实际位置\n如何判断一个数组\n\n\n\n\n\n\n\n\n\n通过 Object.prototype.toString.call()\nObject.prototype.toString.call(obj).slice(8, -1) === 'Array';\n通过原型链做判断\nobj.__proto__ === Array.prototype;\n通过 ES6 的 Array.isArray()做判断\nArray.isArrray(obj);\n通过 instanceof 做判断\nobj instanceof Array;\n通过 Array.prototype.isPrototypeOf\nArray.prototype.isPrototypeOf(obj);\n\n什么是作用域以及作用域链\n\n\n\n\n\n\n\n\n通俗来说就是 声明的变量,函数可以作用的范围\n目的: 提高程序的可靠性, 更重要的是减少命名冲突\n划分: 可分为全局作用域, 局部作用域(函数作用域)块级作用域\n\n全局作用域\n最外层函数和最外层函数外面定义的变量拥有全局作用域\n所有未定义直接赋值的变量自动声明为全局作用域\n所有 window 对象的属性拥有全局作用域\n全局作用域有很大的弊端, 过多的全局作用域变量会污染全局命名空间,容易引起命名冲突\n\n\n局部作用域(函数作用域)\n函数作用域声明在函数内部的变量, 一般只有固定的代码片段可以访问到\n作用域是分层的, 内层作用域可以访问外层作用域,反之不行\n\n\n块级作用域\n使用 ES6 新增的let const可以声明块级作用域, 块级作用域可以在函数中创建, 也可以在一个代码块中创建(由&#123; &#125;包裹的代码片段)\n在循环中比较适合绑定块级作用域\n\n\n\n作用域链: 在当前作用域中查找所需变量,如果该作用域中没有,就会去上一层作用域查找, 依次查找,直到访问到全局作用域,这一层层关系就是作用域链\n什么是闭包?\n\n\n\n\n\n\n\n\n当一个函数的返回值是另一个函数, 而返回的函数又调用了其父函数内部变量,且返回的那个函数在外部被执行, 就产生了闭包\n\n优点\n避免全局变量污染\n变量长期存储在内存中\n\n\n缺点\n如果使用不当, 就会导致变量不会被垃圾回收机制回收.造成内存泄露\n不能及时释放内存\n捕获的变量是引用, 不是复制\n父函数每调用一次就会产生一次闭包\n\n\n\n什么是原型,原型链?\n\n\n\n\n\n\n\n\n原型: 任意一个 js 对象都有一个属性__proto__属性指向一个对象,这个对象就是它的原型对象,, 它可以使用原型对象上的所有属性及方法. 也可以通过这个对象的构造函数上的prototype属性获取原型\n在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 proto 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。\n当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。\n特点： JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。\n\nfunction Perpeo () &#123;&#125;\nvar p1 = new Perpeo()\np1 是 Perpeo的实例, 其上有一个constructor属性指向Perpeo\n即 p1.constructor === Perpeo // true\np1.__proto__ === Perpeo.prototype // true\n\n对于Perpeo而言, 他是一个构造函数, 并且有两个属性, 一个是__proto__属性,指向自身的原型对象, 一个是prototype, Perpeo.prototype.constructor指向其构造函数本身Perpeo\n即 Perpeo.prototype.constructor === Perpeo\t// true\n同时  p1.constructor === Perpeo\n所以 p1.constructor === Perpeo.prototype.constructor\n\n\n原型对象其实也是普通对象\n所有函数对象的proto都指向Function.prototype, 他是一个空函数\n\n\n结论:\n\t1.实例的构造函数属性（constructor）指向构造函数。\n 2.原型对象（Perpeo.prototype）是 构造函数（Perpeo）的一个实例。\n 3.每一个对象都有__proto__属性, 但只有函数对象才有prototype属性\n\n原型链: 获取一个对象的属性或者方法时,当它自身没有的时候, 就会在他的原型对象上去找, 如果还是没有, 会继续向上查找,在原型对象的原型上去找, 直到找到最顶层Object, 如果依然没有, 就会报错, 这个查找的链条关系, 就是原型链\nnew 一个对象的过程\n\n\n\n\n\n\n\n\n\n先创建一个空对象\n设置新对象的__proto__属性指向构造函数的prototype,设置constructor属性指向构造函数本身\n将构造函数中的this指向新对象\n将初始化完毕的新对象的地址,保存到等号左边的变量中\n\n注意: 如果构造函数中返回 his 或者返回值是基本类型的值,则返回新的实例对象, 如果返回值是引用类型的值,则实际返回值为这个引用类型\n什么是 JS 中的事件循环\n\n\n\n\n\n\n\n\n因为 js 是单线程语言, 同一时间只能做一件事, 单线程意味着排队, 前一个任务结束才会执行下一个任务\n从代码执行顺序的角度来看，程序最开始是按代码顺序执行代码的，遇到同步任务，立刻执行；遇到异步任务，则只是调用异步函数发起异步请求。此时，异步任务开始执行异步操作，执行完成后到消息队列中排队。程序按照代码顺序执行完毕后，查询消息队列中是否有等待的消息。如果有，则按照次序从消息队列中把消息放到执行栈中执行。执行完毕后，再从消息队列中获取消息，再执行，不断重复。\n由于主线程不断的重复获得消息、执行消息、再取消息、再执行。所以，这种机制被称为事件循环\nthis 的指向\n\n\n\n\n\n\n\n\n\n哪个对象调用函数，函数里面的 this 指向哪个对象。\n再进行细分\n\n普通函数调用, 指向window,注意: 在严格模式中,这里指向undefined\n\n对象函数调用, 谁调用,就指向谁\n\n构造函数中, this指向该构造函数的实例\n\napply 和 call, 会主动的改变this指向\n\n箭头函数中本身没有this, this指向其上下文环境\n\n\n\n\n常见的数组操作\n\n\n\n\n\n\n\n\n\n不改变原数组\narr.join(&#39;-&#39;) 拼接数组\narr.concat(arr1) 连接数组\narr.slice(firstIndex, endIndex) 截取指定位置的数组, 不包含 endIndex, 可以为负数, 为负数时从数组尾部开始\narr.toString() 将数组转为字符串, 类似与没有参数的 join()\narr.indexOf(value, start) 从左往右查找元素,返回索引, 若没有返回-1, start,可选参数 起始位置,当 start 为复数时, 从右往左开始查找\narr.lastIndexOf(value,statr) 类似与 indexOf\n\n\n改变原数组\narr.pop() 删除数组最后一位, 返回删除的元素\narr.shift() 删除数组第一个元素, 返回删除的元素\narr.unshift(e1,e2,...) 向数组首位新增一个或多个元素, 返回新数组的长度\narr.push(e1,e2,...) 向数组尾部新增一个或多个元素, 返回新数组的长度\narr.reverse() 反转数组, 并返回反转后的数组\narr.sort((a,b) =&gt; a &gt; b | a &lt; b) 排序数组,传入一个函数\narr.splice(start,num,data1,data2) 对数组进行删除,添加,替换, 所有参数都可选\n\n\n遍历数组\narr.forEach()\narr.map()\narr.filter()\narr.some()\narr.every()\narr.reduce()\narr.reduceRight()\n\n\n\n常见的字符串操作\n\n\n\n\n\n\n\n\n\nstr.toLowerCase() 将字符串转为小写\nstr.toUpperCase() 将字符串转为大写\nstr.concat(str2) 连接字符串\nstr.charAt(index) 返回指定下标的字符, 如 index 不在 0 - str.length 之间, 则返回空字符串\nstr.indexOf() 类似与arr.indexOf()\nstr.lastIndexOf() 类似于arr.lastIndexOf()\nstr.slice(start,end) 截取字符串,参数全部可选,可以为负数\nstr.substring(start,end) 截取字符串, 用法同slice(), 但参数不接受负数\nstr.substr(start, length) 截取字符串,第二个参数代表截取的长度\nstr.split() 将字符串以指定的分割字符分割为数组\nstr.replace(target, result) 替换第一个出现的 target 为 result, target 可以为正则表达式\nstr.replaceAll(target, result) 替换所有 target 为 result\nstr.trim() 去掉首位空格\n\n箭头函数与普通函数的区别\n\n\n\n\n\n\n\n\n\n箭头函数没有自身的this\n\n箭头函数更加简洁\n\n没有参数, 可以只写一个括号\n\n如果只有一个参数, 则括号可以省略\n\n如何返回值只有一句, 则 &#123; &#125;可以省略\n\n如果函数体不需要返回值,且只有一句话,可以给这个语句前面加一个void\nlet fn = () => void console.log('1');\n\n\n箭头函数继承来的this指向永远不会改变\n\n箭头函数不能作为构造函数使用, 因为它没有自身的this\n\n箭头函数没有prototype\n\n箭头函数不能做Generator函数, 不能使用yeild关键字\n\n\nES6 新增了那些内容?\n\n\n\n\n\n\n\n\n\n解构, 包括数组解构和对象解构\n模板字符串\n新增声明变量关键字let const\nSymbol\nSet和Map\nProxy\nClass\nfor...in for...of\nPromise\n\nVUEMVC 和 MVVM 区别\n\n\n\n\n\n\n\n\nMVC: 全名是 Model View Controler模型,是软件工程中的一种软件架构模式, 他把软件系统分成三个部分: 模型(model), 视图(view), 控制器(controller)\n\nModel(模型): 处理应用程序中数据逻辑部分\nView(视图): 应用程序中的图形页面\nController(控制器): 处理应用程序中用户交互部分, 例如控制用户输入并向模型发送数据\n\nMVVM: Model View ViewModel 基于 MVC, 新增了 ViewModel 层, 与 MVC 的区别最大之处在于: 实现了 View 和 Model 的自动同步, 也就是当 model 的属性发生改变时, 我们不用再手动的去操作 DOM 来改变 View 的显示, 而是改变属性后会对该属性对应的 View 自动做出改变\n为什么 data 是一个函数\n\n\n\n\n\n\n\n\n如果单纯的写成一个对象, 就使得所有的组件实例共用了一份 data, 就会出现一个变了全部都变的现象, 但如果是一个函数, 返回一个对象, 那么每个实例都有一个独立的 data,不会相互影响\n组件通信的方式有哪些\n\n\n\n\n\n\n\n\n\n父子组件之间:\n父传子 - 父组件可以用过自定义属性, 子组件通过 props 来接收父组件传递过来的数据\n子传父 - 通过自定义事件, 子组件 $emit 出发自定义事件, 父组件监听自定义事件\n也可使用 $parent 和 $children 来获取父子组件实例\n父组件通过 provide 来提供变量, 子组件通过 inject 来注入变量, 这种方式不论子组件的层级有多深, 只要被父组件所包含, 都可以使用 inject 来接收\n$refs 获取组件实例\n\n\n兄弟组件之间\n可以借助父组件, 通过 eventBus 事件中心来传递, 但太过繁琐\nvuex\n\n\n\nvue 的生命周期\n\n\n\n\n\n\n\n\nbeforeCreate: 组件实例初始化后, 此时 data, methods, computed 以及 watch 都不能访问\ncreated : 组件实例初始化完毕,此时 data,methods 等等可以正常访问, 但 页面还没有绘制, 所以 $el 无法访问, 一般请求在此发送\nbeforeMount: 在组件挂载前调用, 相关的 render 函数被调用\nmounted: 组件挂载完毕,数据双向绑定完成, 此时可以访问到 DOM 节点\nbeforeUpdate: 数据发生更新时调用\nupdated: 数据更新完成后调用, 此时 DOM 已经完成更新, 注意切勿在此阶段更新数据, 可能会造成无限循环的更新\nbeforeDestroy:组件实例销毁前调用, 在此实例还可正常访问,可以在此做一些收尾的工作, 例如 清除定时器, 移除监听的事件等\ndestroyed: 组件实例销毁后调用\nactivated: keep-alive 专属, 组件被激活时调用\ndeactivated: keep-alive 专属, 组件被隐藏时调用\nv-if 和 v-show 的区别\n\n\n\n\n\n\n\n\nv-if: 在第一次渲染时,如果条件为false,则不会绘制,直到条件为 true时才会渲染\nv-show: 属性display: none的切换\n在不需要频繁切换的场景下使用 v-if,\nv-show适合需要频繁切换的场景\n一些 vue 的内置指令\n\n\n\n\n\n\n\n\n\nv-once: 只渲染一次,包括组件和所有子节点, 之后不会在随数据变化而改变, 将被视为静态内容\nv-clock: 配合 css [v-clock] &#123; display: none &#125;一起使用, 他会在属性编译结束后显示\nv-model: 双向数据绑定, 实际上是 value 和 input 的语法糖\nv-for: 循环\nv-if: 条件渲染\nv-show: 也可以算是条件渲染\nv-on: 绑定事件, 可以简写为@\nv-bind: 绑定属性, 可以简写为 :\nv-pre: 跳过这个元素与它子元素的编译过程,加快编译速度\nv-text: 设置元素的 textContext\nv-html: 设置元素的 innerHTML\nv-solt: 插槽\n\n如何理解 Vue 的单向数据流\n\n\n\n\n\n\n\n\n数据总数从父组件传递到子组件中,子组件没有权利修改父子间传递过来的数据, 只能请求父组件对原始数据进行修改,这样会防止子组件意外的改变父组件的状态,从而导致你的应用数据流向难以理解\nComputed 和 Watch 的区别\n\n\n\n\n\n\n\n\n\ncomputed: 计算属性, 依赖其他属性而的出一个新的属性,并且computed有缓存, 只有当依赖的数据发生改变时才会重新计算返回的内容, 他可以设置 getter和 setter\nwatch: 侦听器, 监听某一属性发生改变而去执行一些逻辑,\n\n\n计算属性一般用于模板渲染中, 某个值时依赖与其他值甚至可以是其他计算属性得来, 而侦听器更适用于在某一个值发生改变时去完成一系列复杂的业务逻辑\n\nv-if 和 v-for 为什么不建议一起用\n\n\n\n\n\n\n\n\n因为在解析时会先解析v-for再解析v-if, 这样会带来性能方面的浪费, 每次渲染前都会先循环再进行条件判断\n为避免这种情况, 如果条件出现在循环内部, 可以先通过计算属性过滤掉不需要显示的选项\n如果出现在外部, 则可以在外层嵌套template,在这一层进行条件判断,\nVue2, Vue3 响应式数据原理\n\n\n\n\n\n\n\n\nvue2: 数据劫持 + 观察者模式\n对象内部通过 defineReactive方法, 使用Object.defineProperty将对象属性进行劫持(只劫持已经存在的属性), 数组则是通过重写数组来实现\nvue3: 通过 es6 的 Proxy来实现\nvue3 相比 vue2 有哪些改变\n\n\n\n\n\n\n\n\n\n响应式原理发生改变\n组件选项声明方式: v3 使用 Composition API setup 是 v3 新增的一个选项, 他是组件内使用Composition API的入口\n模板语法变化, 自定义指令v-model升级\n组件可以有多个根节点\n\nvue 父子组件声明周期执行顺序\n\n\n\n\n\n\n\n\n加载渲染过程\n\n父 beforeCreate -&gt; 父 created -&gt; 父 beforeMounted -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMounted -&gt; 子 mounted -&gt; 父 mounted\n子组件更新\n\n\n\n\n\n\n\n\n\n父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated\n父组件更新\n\n\n\n\n\n\n\n\n\n父 beforeUpdate -&gt; 父 updated\n销毁过程\n\n\n\n\n\n\n\n\n\n父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed\n\n虚拟 Dom 是什么? 有什么优缺点\n\n\n\n\n\n\n\n\n虚拟Dom(Virtua DOMl)本质上就是使用一个 js 对象去描述一个 DOM 节点, 是对一个真实 DOM 的一层抽象\n\n优点\n保证性能下限: 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，他的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，既保证性能的下限。\n无需手动操作 DOM: 我们不需手动去操作 DOM，只需要写好 View-Model 的 代码逻辑，框架会根据虚拟 DOM 和数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率。\n跨平台: 虚拟 DOM 本质上是 JavaScript 对象，而 DOM 与平台相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器端渲染、weex 开发等等。\n\n\n缺点\n无法做到极致优化: 虽然虚拟 DOM + 合理的优化，足以应对大部分应用的性能需要，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。\n首次渲染大量 DOM 时，由于多了一层 DOM 计算，会比 innerHTML 插入慢。\n\n\n\nv-model 原理\n\n\n\n\n\n\n\n\nv-model只是一个语法糖\nv-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件\n\ntext 和 textarea 元素使用 input 事件和 value 属性\ncheckbox 和 radio 使用 change 事件和 checked 属性\nselect 将 value 作为属性并将 change 作为事件\n\nv-for 为什么一定要加 key, 为什么不建议使用 index 作为 key\n\n\n\n\n\n\n\n\n提高渲染性能,在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。\nindex 作为 key,只适用于不操作当作循环的 list 操作时,但凡有对当前遍历对象有增删改的需求时, 就不能用 index 作为 key\nvue 的性能优化\n\n\n\n\n\n\n\n\n\n对象层级不能过深,否则性能就会差\n不需要响应式的数据不要放在 data 中(可以使用 Object.freeze()冻结数据)\nv-if 与 v-show 合理运用\n合理运用 computed 和 watch\nv-for 必须增加 key, 且 key 避免使用 index,同时避免使用 v-if\n及时清除定时器以及监听事件\n图片懒加载\n路由懒加载\n异步路由\n第三方组件按需加载\n合理运用 keep-alive 组件\n防抖,节流\n\nvm.$nextTick()使用场景\n\n\n\n\n\n\n\n\n在数据更新后立即调用这个方法, 获取更新后的 DOM\nvue 有哪些事件修饰符\n\n\n\n\n\n\n\n\n.stop 阻止事件冒泡\n.prevent 阻止默认行为, 比如 a 标签的默认跳转\n.capture 添加事件监听器时使用事件捕获模式,即内部元素触发的事件先在此处理，然后才交由内部元素进行处理\n.self 只当在事件目标是元素自身是触发处理函数\n.once 事件只触发一次\n.passive 滚动事件的默认行为 (即滚动行为) 将会立即触发\nVueXvuex 是什么?\n\n\n\n\n\n\n\n\nvuex 是专门为 vue 应用程序开发的全局状态管理插件, 简单来说: 应用遇到多个组件共享状态时使用 vuex\nvuex 有哪几种属性\n\n\n\n\n\n\n\n\nState, Getter, Mutation, Action, Module\n\nstate: 存储数据\ngetter: 从 state 中派生来的数据, 相当于基于 state 的计算属性\nmutation : 提交更新数据的方法, 必须是同步的,每个 mutation 都有一个字符串的事件类型(type), 和一个回调函数(handle),回调函数就是我们实际进行状态更改的地方, 并且会接收 state 作为第一个参数, 提交载荷作为第二个参数\naction : 和 mutation 大致相同, 不同的是, action 里可以有任何异步操作\nmodule : 模块化 vuex, 可以让每一个都有自己的 state,mutation,action,getters,使得结构变得更加清晰,方便管理\n\n如何改变 state 中的状态\n\n\n\n\n\n\n\n\n只能显示的commit 一个 mutation\n在模块中, getter, mutation, action 怎么访问全局的 state 和 getter\n\n\n\n\n\n\n\n\n\n在getter中可以通过第三个参数 rootState 访问全局的state, 可以通过第四个参数rootGetters获取全局的getter\n在mutation不可以访问全局的state和getter, 只能访问局部的state\n在action中第一个参数context的context.rootState访问全局的state, context.rootGetters访问全局的 getter\n\n用过 Vuex 模块的命名空间吗？为什么使用，怎么使用。\n\n\n\n\n\n\n\n\n默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间，如果多个模块中 action、mutation 的命名是一样的，那么提交 mutation、action 时，将会触发所有模块中命名相同的 mutation、action。\n这样有太多的耦合，如果要使你的模块具有更高的封装度和复用性，你可以通过添加namespaced: true 的方式使其成为带命名空间的模块。\nexport default &#123;\n  namespaced: true,\n  state,\n  getters,\n  mutations,\n  actions,\n&#125;;\n怎么在带命名空间的模块内提交全局的 mutation 和 action？\n\n\n\n\n\n\n\n\n将 &#123; root: true &#125; 作为第三参数传给 dispatch 或 commit 即可。\nthis.$store.dispatch('actionA', null, &#123; root: true &#125;);\nthis.$store.commit('mutationA', null, &#123; root: true &#125;);\n怎么在带命名空间的模块内注册全局的 action？\n\n\n\n\n\n\n\n\nactions: &#123;\n    actionA: &#123;\n        root: true,\n        handler (context, data) &#123; ... &#125;\n    &#125;\n  &#125;\n组件中怎么提交 modules 中的带命名空间的 moduleA 中的 mutationA？\n\n\n\n\n\n\n\n\nthis.$store.commit('moduleA/mutationA', data);\n怎么使用 mapState，mapGetters，mapActions 和 mapMutations 这些函数来绑定带命名空间的模块？\n\n\n\n\n\n\n\n\n首先使用createNamespacedHelpers创建基于某个命名空间辅助函数\nimport &#123; createNamespacedHelpers &#125; from 'vuex';\nconst &#123; mapState, mapActions &#125; = createNamespacedHelpers('moduleA');\nexport default &#123;\n  computed: &#123;\n    // 在 `module/moduleA` 中查找\n    ...mapState(&#123;\n      a: (state) => state.a,\n      b: (state) => state.b,\n    &#125;),\n  &#125;,\n  methods: &#123;\n    // 在 `module/moduleA` 中查找\n    ...mapActions(['actionA', 'actionB']),\n  &#125;,\n&#125;;\nVue-Router如何重定向页面\n\n\n\n\n\n\n\n\n// 1\nconst router = new VueRouter(&#123;\n  routes: [&#123; path: '/a', redirect: '/b' &#125;],\n&#125;);\n\n// 2\nconst router = new VueRouter(&#123;\n  routes: [&#123; path: '/a', redirect: &#123; name: 'foo' &#125; &#125;],\n&#125;);\n\n// 3\nconst router = new VueRouter(&#123;\n  routes: [\n    &#123;\n      path: '/a',\n      redirect: (to) => &#123;\n        const &#123; hash, params, query &#125; = to;\n        if (query.to === 'foo') &#123;\n          return &#123; path: '/foo', query: null &#125;;\n        &#125; else &#123;\n          return '/b';\n        &#125;\n      &#125;,\n    &#125;,\n  ],\n&#125;);\n如何配置 404 页面\n\n\n\n\n\n\n\n\nconst router = new VueRouter(&#123;\n  routes: [\n    &#123;\n      path: '*',\n      redirect: &#123; path: '/' &#125;,\n    &#125;,\n  ],\n&#125;);\n路由有几种模式, 说说他们的区别\n\n\n\n\n\n\n\n\n\nHash\n兼容所有浏览器, 包括不支持 html5 History Api 的浏览器, hash 改变会触发 hashChange 事件, 通过监听hashChange事件完成操作实现前端路由, hash 改变不会让浏览器向服务器请求\n// 监听hash变化，点击浏览器的前进后退会触发\nwindow.addEventListener(\n  'hashchange',\n  function (event) &#123;\n    let newURL = event.newURL; // hash 改变后的新 url\n    let oldURL = event.oldURL; // hash 改变前的旧 url\n  &#125;,\n  false\n);\nHistory\n兼容能支持 html5 History Api 的浏览器, 依赖 html5 History Api 来实现前端路由, url 中没有#, 路由地址和正常的 url 一样,但初次访问或者刷新都会向服务器请求,没有请求到对应的资源就会返回 404 ,\n\n\n如何在组件中监听路由参数的变化?\n\n\n\n\n\n\n\n\n// 1\nwatch: &#123;\n    '$route'(to, from) &#123;\n        // 逻辑部分\n    &#125;\n&#125;\n\n// 2\nbeforeRouteUpdate(to,from,next) &#123;\n    // 逻辑部分\n&#125;\n如何实现路由懒加载\n\n\n\n\n\n\n\n\nfunction load(component) &#123;\n  //return resolve => require([`views/$&#123;component&#125;`], resolve);\n  return () => import(`views/$&#123;component&#125;`);\n&#125;\n\nconst routes = [\n  &#123;\n    path: '/home',\n    name: 'home',\n    component: load('home'),\n    meta: &#123;\n      title: '首页',\n    &#125;,\n  &#125;,\n];\n","slug":"常见面试题汇总","date":"2022-01-15T02:27:39.000Z","categories_index":"","tags_index":"面试","author_index":"王磊磊"},{"id":"d47852c35da621e678567ca7ca097171","title":"Vue2 & HandsonTable","content":"Vue2 &amp; HandsonTable安装npm install handsontable @handsontable/vue\n\n基本用法&lt;template>\n  &lt;hot-table :data=\"data\" :rowHeaders=\"true\" :colHeaders=\"true\">&lt;/hot-table>\n&lt;/template>\n\n&lt;script>\n  // 引入组件\n  import &#123; HotTable &#125; from '@handsontable/vue';\n  import &#123; registerAllModules &#125; from 'handsontable/registry';\n\n  // 注册所有模块\n  registerAllModules();\n\n  export default &#123;\n    data: function () &#123;\n      return &#123;\n        data: [\n          ['', 'Ford', 'Volvo', 'Toyota', 'Honda'],\n          ['2016', 10, 11, 12, 13],\n          ['2017', 20, 11, 14, 13],\n          ['2018', 30, 15, 12, 13],\n        ],\n      &#125;;\n    &#125;,\n    components: &#123;\n      HotTable,\n    &#125;,\n  &#125;;\n&lt;/script>\n// 引入样式\n&lt;style src=\"../node_modules/handsontable/dist/handsontable.full.css\">&lt;/style>\n\n基础配置 Options {}\ndata: array[array], array[object]\n\n\n\n\n\n\n\n\n\n数据源\n\ncolHeaders: string|array[string] | function(index)\n\n\n\n\n\n\n\n\n\n表头, 若为函数,则函数会接收一个参数,为列的索引\n\n\n\n\n\n\n\n\n\n也可使用嵌套表头\n\nrowHeaders\n\n….\n\n\nColumn\n列头\n\n嵌套列头\n\n列的显示/隐藏\n\n列移动 manualColumnMove\n\n列冻结(固定)\n\n自定义列宽 colWidth: number | arr[number] | function\n\n列汇总 columnSummary\n\n列的虚拟化\n\n列菜单 dropdownMenu: true 为列头添加一个可下拉的菜单, 下拉的菜单可通过dropdownMenu来配置\n\n列数据过滤\n\n\nRow\n嵌套行 nestedRows: Boolean 对数据格式有要求\n\n隐藏行 hiddenRows: Boolean | &#123;rows: [number(需要隐藏的行)], indicators: Boolean (展示隐藏指示器), copyPasteEnabled: Boolean(隐藏的行是否能复制)&#125;, 也可使用getPlugin(&#39;hiddenRows&#39;).hidden(number | [number])来隐藏, 与之对应的还有个getPlugin(&#39;hiddenRows&#39;).showRows(number | [number])\n\n移动行manualRowMove: boolean\n\n冻结行 fixedRowsTop \n\n行高度 rowHeights: number | array[number] | function(index: 行索引) : number &#123;&#125;, 通过 manualRowResize： boolean 可开启手动调整行高度，但必须设置 rowHeaders： true\n\n行懒加载 就是在数据量大的情况下不会全部加载，而是只加载可视区域的数据，这个是默认开启的， 可通过 renderAllRows： true 来关闭\n\n\n\n\n\n\n\n\n\n可通过 viewportRowsRenderingOffset来配置不可见区域加载的数量\n\n排序 不会改变数据，只会改变 UI。 可通过 columnSorting: true 来开启， 默认会有一个排序算法， 也可以自定义排序算法\n\n\n\n\n\n\n\n\n\ncolumnSorting 的值也可为一个 object，例如\n&#123;\n  ...,\n  columnSorting: &#123;\n    initialConfig: &#123; // 默认排序的列\n      column: Number,\n      sortOrder: 'asc' | 'desc'\n    &#125;，\n    indicator: boolean, // 是否显示排序指示器\n    sortEmptyCells: boolean， // 空单元格是否参与排序\n    headerAction: boolean,  // 是否可以点击表头排序\n    compareFunctionFactory: Function, // 排序函数\n    ....\n  &#125;,\n  ...\n&#125;\n自定义行渲染器\n\n\n单元格特性\n复制剪切&amp;粘贴\n\n单元格选中 selectionMode: &#39;single&#39; | &#39;range&#39; | &#39;multiple&#39; \n\n\n\n\n\n\n\n\n\nsingle : 选择单个单元格range : 选择一个范围单元格multiple： 选择多个不连续的单元格\n\n\n\n\n\n\n\n\n\n将选中的数据以 json 格式获取 getSelected()修改选中的数据 setDataAtCell(rowIndex, columnIndex, data)修改选中的单元格元数据 setCellMeta(rowIndex, columnIndex, changeProp, data)\n\n合并单元格\n\n\nAPItoPhysicalColumn(column)\n\n\n\n\n\n\n\n\n\n将可视列的索引转换为物理索引\ntoPhysicalRow(row)\n\n\n\n\n\n\n\n\n\n将可视行的索引转换为物理索引\n其实就是一个 table 插件,通过各种配置项来设置表格\n","slug":"Vue2 & HandsonTable","date":"2022-11-12T13:13:00.166Z","categories_index":"","tags_index":"","author_index":"王磊磊"},{"id":"afa32df1f35d09962e2f7a8a37b37d78","title":"什么是微前端","content":"微前端\n\n\n\n\n\n\n\n\n大型 web 应用, 多个团队共同开发, 根据功能, 业务等等原因进行拆分, 拆分为一个个独立的小应用, 每个小应用之间独立运行, 独立部署, 独立开发,. 再由一个容器对一个个小应用进行组合管理.\n特点\n与技术栈无关, 可以在主应用中引入不同技术栈的子应用\n\n独立开发, 独立部署, 独立运行\n\n相互之间互相隔离, 互不影响\n\n\n","slug":"micro-front","date":"2022-11-12T13:13:00.166Z","categories_index":"","tags_index":"","author_index":"王磊磊"},{"id":"b6d116003eba6679013bb874d6b3449f","title":"数组交集、差集、并集、补集","content":"const arr1 = [1, 2, 3, 4, 5, 6];\nconst arr2 = [4, 5, 6, 7, 8, 9];\n\nconst sArr1 = new Set(arr1);\nconst sArr2 = new Set(arr2);\n\n// 交集\nconst a1 = arr1.filter(i => sArr2.has(i));\n// 差集\nconst a2 = arr1.filter(i => !sArr2.has(i));\nconst a3 = arr2.filter(i => !sArr1.has(i));\n// 并集\nconst a4 = [...new Set([...arr1, ...arr2])];\n\nconsole.log('a1', a1); //  [ 4, 5, 6 ]\nconsole.log('a2', a2); //  [ 1, 2, 3 ]\nconsole.log('a3', a3); //  [ 4, 5, 6 ]\nconsole.log('a4', a4); //  [ 1, 2, 3, 4, 5, 6, 7, 8, 9]\n","slug":"数组交集、差集、并集、补集","date":"2022-11-11T05:47:24.000Z","categories_index":"","tags_index":"Array","author_index":"王磊磊"},{"id":"f74174ce65914f55b350a7c7cd07baeb","title":"HandsonTable-Plugin-UndoRedo","content":"HandsonTable Plugin UndoRedo撤销恢复插件\noptionsundooption.undo : boolean\n默认: undefined\n开启关闭插件\nMethodsclearundoRedo.clear()\n清楚撤销恢复历史记录\ndestroyundoRedo.destroy()\n销毁实例\ndisableundoRedo.disable()\n禁用插件\nenableundoRedo.enable()\n启用插件\ndoneundoRedo.done(wrappedAction, [source])\n隐藏有关已执行操作的信息\nEmits: Hooks#event:beforeUndoStackChange, Hooks#event:afterUndoStackChange, Hooks#event:beforeRedoStackChange, Hooks#event:afterRedoStackChange\nisEnabledundoRedo.isEnabled() ⇒ boolean\n插件是否开启\nisRedoAvailableundoRedo.isRedoAvailable() ⇒ boolean\n恢复操作是否可用\nisUndoAvailableundoRedo.isUndoAvailable() ⇒ boolean\n撤销操作是否可用\nredoundoRedo.redo()\n恢复操作\nEmits: Hooks#event:beforeUndoStackChange, Hooks#event:afterUndoStackChange, Hooks#event:beforeRedoStackChange, Hooks#event:afterRedoStackChange, Hooks#event:beforeRedo, Hooks#event:afterRedo\nundoundoRedo.undo()\n撤销操作\nEmits: Hooks#event:beforeUndoStackChange, Hooks#event:afterUndoStackChange, Hooks#event:beforeRedoStackChange, Hooks#event:afterRedoStackChange, Hooks#event:beforeUndo, Hooks#event:afterUndo\n\n如有错误望指出, 蟹蟹.\n","slug":"HandsonTable-Plugin-UndoRedo","date":"2022-05-13T02:27:56.000Z","categories_index":"","tags_index":"HandsonTable","author_index":"王磊磊"},{"id":"3d78fd11f83a61156328d53929a4b580","title":"Handsontable-Core","content":"HandsonTable All CoreHandsonTable实例上的方法, 用于获取或者设置表格\n\n\n\n\n\n\n\n\n\nHow to use?\n// 1.实例化表格\nconst hot = new Handsontable(document.getElementById('example'), options);\n\n// 2.使用\nhot.setDataAtCell(0, 0, 'new value');\nMethodsaddHookcore.addHook(key, callback)\n为实例添加一个指定name的hook, 以及触发的回调函数\naddHookOncecore.addHookOnce(key, callback)\n为实例添加一个只会触发一次的指定name的hook, 以及触发的回调函数\naltercore.alter(action, index, [amount], [source], [keepEmptyRows])\n修改表格, 但是只适用于数据结构为数组的\n\n\n\nParam\nType\nDefault\nDescription\n\n\n\naction\nstring\n\n可能的值insert_row,insert_col,remove_row,remove_col\n\n\nindex\nnumber Array&lt;number&gt;\n\n在新行/列插入或者移除前的索引\n\n\n[amount]\nnumber\n1\n要插入或者删除的行数或者列数\n\n\n[source]\nstring\n\n来源指示器\n\n\n[keepEmptyRows]\nboolean\n\n是否防止删除空行\n\n\nbatchcore.batch(wrappedOperations) ⇒ void\n此方法用于将多个渲染与重新计算表格的方法收集在一起, 通俗说就是将多个更新汇集成一个更新, 之后重新渲染表格\n\n点击查看示例\nhot.batch(() => &#123;\n  hot.alter('insert_row', 5, 45);\n  hot.alter('insert_col', 10, 40);\n  hot.setDataAtCell(1, 1, 'x');\n  hot.setDataAtCell(2, 2, 'c');\n  hot.setDataAtCell(3, 3, 'v');\n  hot.setDataAtCell(4, 4, 'b');\n  hot.setDataAtCell(5, 5, 'n');\n  hot.selectCell(0, 0);\n\n  const filters = hot.getPlugin('filters');\n\n  filters.addCondition(2, 'contains', ['3']);\n  filters.filter();\n  hot.getPlugin('columnSorting').sort(&#123; column: 1, sortOrder: 'desc' &#125;);\n  // The table will be re-rendered and cache will be recalculated once after executing the callback\n&#125;);\n\n\n\nbatchExecutioncore.batchExecution(wrappedOperations, [forceFlushChanges]) ⇒  void\n与batch相比不同在于不会重新渲染表格, 对于第二个参数, 如果为true, 则在执行完操作后, 会重新计算表格内部缓存\nbatchRendercore.batchRender(wrappedOperations) ⇒ void\n与batch类似\nclearcore.clear()\n清楚表格数据,不会改变表格设置\nclearUndocore.clearUndo() ⇒ boolean\n清除撤销\ncolToPropcore.colToProp(column) ⇒ string | number\n返回与给定列索引对应的属性名。如果数据源是数组的数组，则返回列索引\npropToColcore.propToCol(prop) ⇒ number\n给定属性返回列索引\ncountColscore.countCols() ⇒ number\n返回总列数\ncountEmptyColscore.countEmptyCols([ending]) ⇒ number\n返回空列的总数, 可选参数如为true, 则只计算数据源末尾的空列\ncountEmptyRowscore.countEmptyRows([ending]) ⇒ number\n返回空行的总数, 可选参数如为true, 则只计算数据源末尾的空行\ncountRenderedColscore.countRenderedCols() ⇒ number\n返回渲染的列数, 包括在可视区域以外的, 返回-1则表格不可见\ncountRenderedRowscore.countRenderedRows() ⇒ number\n返回渲染的行数, 包括在可视区域以外的, 返回-1则表格不可见\ncountRowscore.countRows() ⇒ number\n返回可视行的总数\ncountSourceColscore.countSourceCols() ⇒ number\n返回数据源中的总列数\ncountSourceRowscore.countSourceRows() ⇒ number\n返回数据源中的总行数\ncountVisibleColscore.countVisibleCols() ⇒ number\n返回仅在表视口中可见的呈现列数。部分可见的列不计算在内\ncountVisibleRowscore.countVisibleRows() ⇒ number\n返回仅在表视口中可见的呈现行数。部分可见的列不计算在内\ndeselectCellcore.deselectCell()\n取消当前选中的单元格\ndestroycore.destroy()\n从DOM中移除表格并销毁Handsontable实例\ndestroyEditorcore.destroyEditor([revertOriginal], [prepareEditorIfNeeded])\n销毁当前编辑器，呈现表格并准备新选定单元格的编辑器。\n\n\n\nParam\nType\nDefault\nDescription\n\n\n\n[revertOriginal]\nboolean\nfalse\n如果为true，将恢复先前的值。否则，将保存编辑的值。\n\n\n[prepareEditorIfNeeded]\nboolean\ntrue\n如果为true,所选单元格下的编辑器将准备打开\n\n\nemptySelectedCellscore.emptySelectedCells([source])\n擦除表格中选定单元格的内容, 可选参数类型为string, 在afterChange和beforeChange中可以拿到设置的source\ngetActiveEditorcore.getActiveEditor() ⇒ BaseEditor\n返回激活的编辑器实例\ngetCellcore.getCell(row, column, [topmost]) ⇒ HTMLTableCellElement | null\n如果它渲染在屏幕上, 则返回给定行和列参数的TD元素。如果没有呈现在屏幕上，则返回null(可能是因为表的这一部分不可见)\ngetCellEditorcore.getCellEditor(row, column) ⇒ function\n获取单元格编辑器\ngetCellMetacore.getCellMeta(row, column) ⇒ object\n返回单元格的属性对象\nEmits: Hooks#event:beforeGetCellMeta, Hooks#event:afterGetCellMeta\ngetCellMetaAtRowcore.getCellMetaAtRow(row) ⇒ Array\n返回指定行索引的单元格元对象数组。\ngetCellRenderercore.getCellRenderer(row, column) ⇒ function\n获取指定单元格的渲染器函数\ngetCellsMetacore.getCellsMeta() ⇒ Array\n在表格中至少获得一次生成的所有单元格设置(按照单元初始化的顺序)。\ngetCellValidatorcore.getCellValidator(row, column) ⇒ function | RegExp | undefined\n获取指定单元格验证器\ngetColHeadercore.getColHeader([column]) ⇒ Array | string | number\n返回列头数组\nEmits: Hooks#event:modifyColHeader\ngetRowHeadercore.getRowHeader([row]) ⇒ Array | string | number\n获取行头\nEmits: Hooks#event:modifyRowHeader\ngetColWidthcore.getColWidth(column) ⇒ number\n获取指定列宽\nEmits: Hooks#event:modifyColWidth\ngetRowHeightcore.getRowHeight(row) ⇒ number\n获取指定行高\n\n\n\n\n\n\n\n注意\n注意，这个方法不同于AutoRowSize插件的getRowHeight()。\n\n\nEmits: Hooks#event:modifyRowHeight\ngetCoordscore.getCoords(element) ⇒ CellCoords | null\n返回单元格位置\ngetCopyableDatacore.getCopyableData(row, column) ⇒ string\n返回指定位置的可复制的数据\ngetCopyableTextcore.getCopyableText(startRow, startCol, endRow, endCol) ⇒ string\n返回选定范围的字符串值。每一列由制表符分隔，每一行由新的行字符分隔。\ngetDatacore.getData([row], [column], [row2], [column2]) ⇒ Array&lt;Array&gt;\n获取数据对象, 与options:data或者loadData传递的数据对象相同, 也可以指定参数获取部分区域的数据对象\ngetDataAtCellcore.getDataAtCell(row, column) ⇒ void\n返回指定单元格的值,\n\n\n\n\n\n\n提示\n如果数据发生改变(排序或者拖拽行列, 则按照当前渲染的表格索引)\n\n\ngetDataAtColcore.getDataAtCol(column) ⇒ Array\n获取指定列的数据\ngetDataAtPropcore.getDataAtProp(prop) ⇒ Array\n获取指定属性的数据value\ngetDataAtRowcore.getDataAtRow(row) ⇒ Array\n获取指定行的数据\ngetDataAtRowPropcore.getDataAtRowProp(row, prop) ⇒ void\n获取指定行和属性的value\ngetDataTypecore.getDataType(rowFrom, columnFrom, rowTo, columnTo) ⇒ string\n返回在option:type中定义的值, 如果范围内有不同类型的值, 则返回mixed\ngetDirectionFactorcore.getDirectionFactor() ⇒ number\n为LTR返回1；-1代表RTL。对计算有用。\ngetInstancecore.getInstance() ⇒ Handsontable\n返回Handsontable实例\ngetPlugincore.getPlugin(pluginName) ⇒ BasePlugin| undefined\n获取插件\ngetSchemacore.getSchema() ⇒ object\n返回由构造函数设置提供的架构。如果它不存在，那么它根据第一行中的数据结构返回模式。\ngetSelectedcore.getSelected() ⇒ Array&lt;Array&gt; | undefined\n获取选中的单元格位置\ngetSelectedLastcore.getSelectedLast() ⇒ Array | undefined\n获取选中的最后一个单元格坐标\ngetSelectedRangecore.getSelectedRange() ⇒ Array&lt;CellRange&gt; | undefined\n以CellRange对象的数组形式返回当前选定的区域\ngetSelectedRangeLastcore.getSelectedRange() ⇒ Array&lt;CellRange&gt; | undefined\n以CellRange对象的数组形式返回当前选定的区域的最后一个\ngetSettingscore.getSettings() ⇒ TableMeta\n获取设置对象\ngetShortcutManagercore.getShortcutManager() ⇒ ShortcutManager\n返回负责处理存储在某些上下文中的快捷方式的管理器的实例。它在激活的可触摸实例中按下组合键后运行动作。\ngetSourceDatacore.getSourceData([row], [column], [row2], [column2]) ⇒ Array | Array\n获取数据源的数据\ngetSourceDataArraycore.getSourceDataArray([row], [column], [row2], [column2]) ⇒ Array\n以数组对象的形式返回表格数据, 即使数据源不为数组对象\ngetSourceDataAtCellcore.getSourceDataAtCell(row, column) ⇒ void\n从数据源返回单个值\ngetSourceDataAtColcore.getSourceDataAtCol(column) ⇒ Array\n从数据源返回指定列的value\ngetSourceDataAtRowcore.getSourceDataAtRow(row) ⇒ Array | object\n返回单行数据\ngetTranslatedPhrasecore.getTranslatedPhrase(dictionaryKey, extraArguments) ⇒ string\n获取指定字典关键字的语言短语。\ngetValuecore.getValue() ⇒ void\n从选定的单元格中获取值。\nhasColHeaderscore.hasColHeaders() ⇒ boolean\n是否配置列头\nhasRowHeaderscore.hasRowHeaders() ⇒ boolean\n是否配置行头\nhasHookcore.hasHook(key) ⇒ boolean\n是否为hook添加了监听\nisColumnModificationAllowedcore.isColumnModificationAllowed() ⇒ boolean\n检查数据格式和配置是否允许用户修改列结构\nisEmptyColcore.isEmptyCol(column) ⇒ boolean\n检查由列参数声明的列中的所有单元格是否都为空。\nisEmptyRowcore.isEmptyRow(row) ⇒ boolean\n检查行中的单元格是否都为空\nisExecutionSuspendedcore.isExecutionSuspended() ⇒ boolean\n检查表索引重新计算过程是否已暂停\nisListeningcore.isListening() ⇒ boolean\n如果当前Handsontable实例正在监听文档正文上的键盘输入，则返回true。\nisLtrcore.isLtr() ⇒ boolean\n当前表格布局是否是由左向右\nisRtlcore.isRtl() ⇒ boolean\n但当前表格布局是否由右向左\nisRedoAvailablecore.isRedoAvailable() ⇒ boolean\n恢复操作是否可用\nisUndoAvailablecore.isUndoAvailable() ⇒ boolean\n撤销操作是否可用\nisRenderSuspendedcore.isRenderSuspended() ⇒ boolean\n检查表格渲染过程是否暂停\nlistencore.listen()\n监听表格上的键盘输入\nEmits: Hooks#event:afterListen\nunlistencore.unlisten()\n停止监听表格上的键盘输入\nloadDatacore.loadData(data, [source])\n加载数据\nupdateDatacore.updateData(data, [source])\nEmits: Hooks#event:beforeUpdateData, Hooks#event:afterUpdateData, Hooks#event:afterChange\nupdateSettingscore.updateSettings(settings, [init])\nEmits: Hooks#event:afterCellMetaReset, Hooks#event:afterUpdateSettings\n更新配置\n\n\n\n\n\n\n提示\n如果您需要在初始化后更改配置，请使用它。settings参数是一个包含已更改设置的对象，其声明方式与初始settings对象相同。 请注意，尽管updateSettings方法不会覆盖以前声明的设置，但它可能会重置初始化后进行的设置。(例如，忽略使用columnResize特性所做的更改)。 由于8.0.0在设置对象内传递列或数据将导致重置对应于行和列的状态(例如，行/列顺序、列宽、行高、冻结列等。). 从12.0.0开始，在设置对象内部传递数据不再导致重置对应于行和列的状态(例如，行/列顺序、列宽、行高、冻结列等)。).\n\n\npopulateFromArraycore.populateFromArray(row, column, input, [endRow], [endCol], [source], [method], direction, deltas) ⇒ object | undefined\n用二维数组填充指定的单元格\nredocore.redo() ⇒ boolean\n恢复操作\nundocore.undo() ⇒ boolean\n撤销操作\nrefreshDimensionscore.refreshDimensions()\n更新表格的尺寸。该方法将以前的维度与当前的维度进行比较，并相应地进行更新。\nEmits: Hooks#event:beforeRefreshDimensions, Hooks#event:afterRefreshDimensions\nremoveCellMetacore.removeCellMeta(row, column, key)\n针对所提供的行和列坐标，从单元格元对象中移除由key参数定义的属性。\nEmits: Hooks#event:beforeRemoveCellMeta, Hooks#event:afterRemoveCellMeta\nremoveHookcore.removeHook(key, callback)\n移除添加的hook监听\nrendercore.render()\n重新渲染表格。调用此方法将启动重新计算、重绘和应用对DOM的更改的过程。渲染表格时，所有单元渲染器都会被调用。 不建议手动调用此方法。Handsontable会在其生命周期中的最佳时刻来渲染\nresumeExecutioncore.resumeExecution([forceFlushChanges])\n恢复执行过程。结合Core#suspendExecution方法，它允许聚合表逻辑更改，然后更新缓存。恢复状态会自动调用表缓存更新过程。 该方法旨在供高级用户使用。暂停执行进程可能会导致由于未更新内部表缓存而导致的渲染出错。\nsuspendExecutioncore.suspendExecution()\n暂停执行过程.\nresumeRendercore.resumeRender()\n继续渲染过程。与Core#suspendRender方法相结合，它允许聚合由API调用或UI操作(或两者)触发的表格呈现周期，并在最后调用一次Render。当表处于挂起状态时，在呈现状态恢复之前，大多数操作都没有视觉效果。恢复状态会自动调用表格呈现。 该方法旨在供高级用户使用。如果执行不当，暂停渲染过程可能会导致渲染错误。\nsuspendRendercore.suspendRender()\n暂停渲染过程\nrunHookscore.runHooks(key, [p1], [p2], [p3], [p4], [p5], [p6]) ⇒ void\n使用其他参数中给定的参数，为key参数中提供的hook运行回调。\nscrollViewportTocore.scrollViewportTo([row], [column], [snapToBottom], [snapToRight], [considerHiddenIndexes]) ⇒ boolean\n将滚动条滚动至参数指定位置\nselectAllcore.selectAll([includeHeaders])\n选择整个表格\nselectCellcore.selectCell(row, column, [endRow], [endColumn], [scrollToCell], [changeListener]) ⇒ boolean\n选中指定的范围。如果表被配置为支持数据列属性，则可以使用该属性进行选择。 默认情况下，窗口将滚动到选择。selectCell方法完成后，该实例将监听文档上的键盘输入。\n\n\n\nParam\nType\nDefault\nDescription\n\n\n\nrow\nnumber\n\n行索引\n\n\ncolumn\nnumber\nstring\n\n\n\n[endRow]\nnumber\n\n结束行索引\n\n\n[endColumn]\nnumber\nstring\n\n\n\n[scrollToCell]\nboolean\ntrue\n是否将窗口滚动至选中的范围\n\n\n[changeListener]\nboolean\ntrue\n滚动完成后是否监听文档上的键盘输入\n\n\n\n点击查看示例\n// select a single cell\nhot.selectCell(2, 4);\n// select a single cell using column property\nhot.selectCell(2, 'address');\n// select a range of cells\nhot.selectCell(2, 4, 3, 5);\n// select a range of cells using column properties\nhot.selectCell(2, 'address', 3, 'phone_number');\n// select a range of cells without scrolling to them\nhot.selectCell(2, 'address', 3, 'phone_number', false);\n\n\n\nselectCellscore.selectCells(coords, [scrollToCell], [changeListener]) ⇒ boolean\n进行由行和列值或以endRow、endColumn结束的单元格范围指定的多个不连续的选择。该方法支持两种输入格式，这两种格式与getSelected和getSelectedRange方法生成的格式相同\n\n\n\nParam\nType\nDefault\nDescription\n\n\n\ncoords\nArray&lt;Array&gt; Array&lt;CellRange&gt;\n\n选中单元格的位置\n\n\n[scrollToCell]\nboolean\ntrue\n同selectCell\n\n\n[changeListener]\nboolean\ntrue\n同selectCell\n\n\n\n点击查看示例\n// Using an array of arrays.\nhot.selectCells([[1, 1, 2, 2], [3, 3], [6, 2, 0, 2]]);\n// Using an array of arrays with defined columns as props.\nhot.selectCells([[1, 'id', 2, 'first_name'], [3, 'full_name'], [6, 'last_name', 0, 'first_name']]);\n// Using an array of CellRange objects (produced by `.getSelectedRange()` method).\nconst selected = hot.getSelectedRange();\n\nselected[0].from.row = 0;\nselected[0].from.col = 0;\n\nhot.selectCells(selected);\n\n\n\nselectColumnscore.selectColumns(startColumn, [endColumn]) ⇒ boolean\n选中指定的列\nselectRowscore.selectRows(startRow, [endRow]) ⇒ boolean\n选中指定的行\nsetCellMetacore.setCellMeta(row, column, key, value)\n将key属性定义的属性设置为行和列对应的单元格的meta对象。\nEmits: Hooks#event:beforeSetCellMeta, Hooks#event:afterSetCellMeta\nsetCellMetaObjectcore.setCellMetaObject(row, column, prop)\n将由prop定义的单元元数据对象设置为相应的行和列。\nsetDataAtCellcore.setDataAtCell(row, [column], [value], [source])\n为单元格设置新值, 如设置多个值, 参数格式为[[row, col, val], ... ]\nsetDataAtRowPropcore.setDataAtRowProp(row, prop, value, [source])\n为单元格设置新值, 如设置多个值, 参数格式为[[row, prop, val], ... ]\nsetSourceDataAtCellcore.setSourceDataAtCell(row, column, value, [source])\n设置数据源的值\nspliceCellsMetacore.spliceCellsMeta(visualIndex, [deleteAmount], […cellMetaRows])\n向单元格集合中移除或添加一行或多行单元元对象。\nspliceColcore.spliceCol(column, index, amount, […elements]) ⇒ Array\n在列中添加或者移除数据\nspliceRowcore.spliceRow(row, index, amount, […elements]) ⇒ Array\n在行中添加或者移除数据\ntoHTMLcore.toHTML() ⇒ string\n将实例转换为HTMLTableElement的outerHTML。\ntoPhysicalColumncore.toPhysicalColumn(column) ⇒ number\n将可视列索引转换为真实列索引。 当您希望基于可以重新排序、移动或修剪的可视索引来检索真实列索引时，此方法非常有用。\ntoPhysicalRowcore.toPhysicalRow(row) ⇒ number\n同上\ntoVisualColumncore.toVisualColumn(column) ⇒ number\n与toPhysicalColumn相反\ntoVisualRowcore.toVisualRow(row) ⇒ number\n与toPhysicalRow相反\ntoTableElementcore.toTableElement() ⇒ HTMLTableElement\n将实例转换为HTMLTableElement。\nvalidateCellcore.validateCell(value, cellProperties, callback, source)\n验证单个单元格\nvalidateCellscore.validateCells([callback])\n使用验证器函数验证所有单元格，并在完成时调用回调。 如果其中一个单元格验证失败，回调将使用valid参数作为false来触发——否则它将等于true。\nhot.validateCells((valid) => &#123;\n  if (valid) &#123;\n    // ... code for validated cells\n  &#125;\n&#125;)\n\nvalidateColumnscore.validateColumns([columns], [callback])\n同上, 验证列\nvalidateRowscore.validateRows([rows], [callback])\n同上, 验证行\n\n如有错误请指出, 蟹蟹\n","slug":"Handsontable-Core","date":"2022-05-09T02:54:50.000Z","categories_index":"","tags_index":"Handsontable","author_index":"王磊磊"},{"id":"a9cb558acbb9cfef653d8b10d6ae449f","title":"Handsontbale-Option","content":"Handsontable All OptionsMembersactiveHeaderClassNameoptions.activeHeaderClassName : string\n选中一行或者一列, 行头或者列头添加的css类名\n默认: ht__active_highlight\nallowEmptyoptions.allowEmpty : boolean\n是否允许null undefined &#39;&#39;\n默认: true\n// 在整个表格中允许空值\nallowEmpty: true,\n// 或\ncolumns: [\n    // 在一列中允许空值\n    &#123;\n        data: 'date',\n        allowEmpty: true\n    &#125;\n]\n\nallowHtmloptions.allowHtml : boolean\n默认: false\n是否在autocomplete和dropdown单元格将数据视为HTML\n\n\n\n\n\n\n\n注意\n开启后可能会造成xss攻击\n\n\nallowInsertColumnoptions.allowInsertColumn : boolean\n默认: true\n开启后, 会在上下文菜单中加入下列选项\n\nInsert column left\nInsert column right\n\nallowInsertRowoptions.allowInsertRow : boolean\n默认: true\n开启后, 会在上下文菜单中加入下列选项\n\nInsert row above\nInsert row below\n\nallowInvalidoptions.allowInvalid : boolean\n\n\n\nsetting\ndesc\n\n\n\ntruedefault\n- 接受无效值 - 允许用户关闭含有无效值的单元格编辑器 - 将无效值保存到数据源中\n\n\nfalse\n- 不接受无效值 - 不允许用户关闭含有无效值的单元格编辑器 - 不保存无效值到数据源中\n\n\nallowRemoveColumnoptions.allowRemoveColumn : boolean\n默认: true\n开启后, 会在上下文菜单中加入下列选项\n\nRemove column\n\nallowRemoveRowoptions.allowRemoveRow : boolean\n开启后, 会在上下文菜单中加入下列选项\n\nRemove row\n\nautoColumnSizeoptions.autoColumnSize : object | boolean\n默认: undefined\n配置AutoColumnSize插件。\n\n\n\nsetting\ndesc\n\n\n\nfalse\n关闭AutoColumnSize插件\n\n\ntrue\n开启AutoColumnSize插件并使用默认配置\n\n\nobject\n开启AutoColumnSize插件并修改默认配置\n\n\n当为object时, 可以有以下属性\n\n\n\nprop\nvalue\ndesc\n\n\n\nsyncLimit\nnumber | 百分比字符串(如: ‘40%’)\n默认: 50\n\n\nuseHeaders\nboolean\n计算列宽时是否使用列头\n\n\nsamplingRatio\nnumber\n在列宽计算中使用的相同长度的样本数\n\n\nallowSampleDuplicates\nboolean\n\n\n\n\n\n\n\n\n\n提示\n默认情况下，AutoColumnSize 为 undefined，但autoColumnSize插件的作用是启用。要完全禁用autoColumnSize插件，需要将AutoColumnSize选项设置为false。 使用colWidths选项会强制禁用AutoColumnSize插件。\n\n\nautoRowSizeoptions.autoRowSize : object | boolean\n默认: undefined\n配置AutoRowSize插件。\n\n\n\nsetting\ndesc\n\n\n\nfalse\n关闭AutoRowSize插件\n\n\ntrue\n开启AutoRowSize插件并使用默认配置\n\n\nobject\n开启AutoRowSize插件并修改默认配置\n\n\n当为object时, 可以有以下属性\n\n\n\nprop\nvalue\ndesc\n\n\n\nsyncLimit\nnumber | 百分比字符串(如: ‘40%’)\n默认: 500\n\n\n\n\n\n\n\n\n提示\n\n要给表格的滚动条一个合适的大小, 将autoRowSize设置为true\n\n使用rowHeights选项会强制禁用AutoRowSize插件\n\n\n\n\nautoWrapColoptions.autoWrapCol : boolean\n默认: false\nautoWrapRowoptions.autoWrapRow : boolean\n默认: false\nbindRowsWithHeadersoptions.bindRowsWithHeaders : boolean | string\n开启/关闭binrowswithheaders插件。\n默认: undefined\ncelloptions.cell : Array&lt;Array&gt;\n默认: []\n\n可以配置单个单元格选项\ncell配置的内容会覆盖表格顶层配置的内容和columns配置的内容\n\ncell: [\n    &#123;\n        row: 1,\n        col: 1,\n        readOnly: true\n    &#125;\n]\n\ncellsoptions.cells : function\n默认: undefined\ncells允许根据实现的任何逻辑将配置选项应用到表格(列、行、单元格)。\ncells配置的内容会覆盖所有其他选项(包括由列和单元格设置的选项)。\n\n\n\nprop\nrequired\ntype\ndesc\n\n\n\nrow\nyes\nnum\n行索引\n\n\ncolumn\nyes\nnum\n列索引\n\n\nprop\nno\nstring | number\n如果数据为数组数组, 则prop与column相同, 如果数据为数组对象, 则prop为设置的属性名\n\n\ncheckedTemplateoptions.checkedTemplate : boolean | string | number\n默认: true\n设置选中复选框单元格的值, 通过单元格的getDataAtCell方法可获取设置的值\nclassNameoptions.className : string\n选中单元格类名\n默认: undefined\ncolHeadersoptions.colHeaders : boolean | Array&lt;string&gt; | function\n配置列头\n默认: null\n\n\n\nsetting\ndesc\n\n\n\ntrue\n开启列头, 默认A,B,C,D…..\n\n\nfalse\n关闭列头\n\n\nArray\n定义列头([‘one’, ‘two’, ‘three’, …])\n\n\nfunction(index)\n使用函数定义列头\n\n\ncollapsibleColumnsoptions.collapsibleColumns : boolean | Array&lt;object&gt;\n展开列, 配置 CollapsibleColumns 插件\n默认: undefined\n// enable column collapsing for all headers\ncollapsibleColumns: true,\n\n// enable column collapsing for selected headers\ncollapsibleColumns: [\n  &#123;row: -4, col: 1, collapsible: true&#125;,\n  &#123;row: -3, col: 5, collapsible: true&#125;\n],\n\ncolumnHeaderHeightoptions.columnHeaderHeight : number | Array&lt;number&gt;\n默认: undefined\n配置列头高度\ncolumnHeaderHeight: 25,\n\ncolumnHeaderHeight: [25, 30, 55],\n\ncolumnsoptions.columns : Array&lt;ooject&gt; |  function\n默认: undefined\n配置单个列或者范围列\n\n\n\n\n\n\n提示\n使用columns时，startCols、minCols和maxCols将被忽略。\n\n\n// set the `columns` option to an array of objects\n// each object represents one column\ncolumns: [\n  &#123;\n    // column options for the first (by physical index) column\n    type: 'numeric',\n    numericFormat: &#123;\n      pattern: '0,0.00 $'\n    &#125;\n  &#125;,\n  &#123;\n    // column options for the second (by physical index) column\n    type: 'text',\n    readOnly: true\n  &#125;\n],\n\n// or set the `columns` option to a function, based on physical indexes\ncolumns(index) &#123;\n  return &#123;\n    type: index > 0 ? 'numeric' : 'text',\n    readOnly: index &lt; 1\n  &#125;\n&#125;\n\ncolumnSortingoptions.columnSorting : boolean | object\n列排序, 配置columnSorting插件\n默认: undefined\n\n\n\nsetting\ndesc\n\n\n\ntrue\n开启插件并使用默认配置\n\n\nfalse\n关闭插件\n\n\nobject\n开启插件并使用修改的配置\n\n\n如果为object,则有一下属性\n\n\n\nprop\ntype\ndesc\n\n\n\nindicator\nboolean\n是否在列头显示排序箭头\n\n\nheaderAction\nboolean\n是否可以点击列头排序\n\n\nsortEmptyCells\nboolean\n是否对空单元格进行排序\n\n\ncompareFunctionFactory\nfunction(sortOrder, columnMeta)\n一个函数, 返回一个函数,返回的函数参数有两个,当前值和下一个值,可进行自定义比较,返回-1, 0 1\n\n\ninitialConfig\nobject\n有两个属性,column和sortOrder sortOrder值为asc\n\n\ncolumnSummaryoptions.columnSummary : Array&lt;object&gt; | function\n默认: undefined\n列汇总(合计), 配置ColumnSummary插件\n如果是数组对象, 则有以下属性:\n\n\n\nProp\nType\nDesc\n\n\n\nsourceColumn\nnum\n\n\n\nranges\narray\n\n\n\ntype\nsum\nmin\n\n\ndestinationRow\nnum\n\n\n\ndestinationColumn\nnum\n\n\n\nforceNumeric\nboolean\n\n\n\nreversedRowCoords\nboolean\n\n\n\nsuppressDataTypeErrors\nboolean\n\n\n\nreadOnly\nboolean\n\n\n\nroundFloat\nboolean\n\n\n\ncustomFunction\nfunction\n\n\n\ncolumnSummary: [\n  &#123;\n    sourceColumn: 0,\n    ranges: [\n      [0, 2], [4], [6, 8]\n    ],\n    type: 'custom',\n    destinationRow: 4,\n    destinationColumn: 1,\n    forceNumeric: true,\n    reversedRowCoords: true,\n    suppressDataTypeErrors: false,\n    readOnly: true,\n    roundFloat: false,\n    customFunction(endpoint) &#123;\n       return 100;\n    &#125;\n  &#125;\n],\n\ncolWidthsoptions.colWidths : number | Array&lt;number&gt; | string | Array&lt;string&gt; | undefined | function\n默认: undefined\n以px为单位设置列宽.\n\n\n\n\n\n\n提示\n设置colWidths选项会禁用AutoColumnSize插件。\n\n\n\n\n\nsetting\ne.g\n\n\n\nnumber\ncolWidths: 100\n\n\nstring\ncolWidths: &#39;100px&#39;\n\n\narr\ncolWidths: [100, 120, undefined]\n\n\nfunction\ncolWidths(visualColumnIndex) &#123; return visualColumnIndex * 10; &#125;\n\n\nundefined\ncolWidths: undefined 设置为undefined由modifyColWidthhook函数来检测列宽度变化\n\n\ncommentedCellClassNameoptions.commentedCellClassName : string\n默认: htCommentCell\n向有注释的单元格添加CSS类名。\ncommentsoptions.comments : boolean | Array&lt;object&gt;\n默认: false\n配置Comments插件\n如为object, 则有一下属性:\n\n\n\nprop\ntype\ndesc\n\n\n\ndisplayDelay\nnum(default: 250)\n延迟显示评论时间,单位毫秒\n\n\nreadOnly\nboolean(default: false)\n将注释设置为只读\n\n\nstyle\nobject\n设置注释边框的长和宽\n\n\n// 开启插件\ncomments: true,\n\n\n// 开启插件并配置\ncomments: &#123;\n  // display all comments with a 1-second delay\n  displayDelay: 1000,\n  // make all comments read-only\n  readOnly: true,\n  // set the default size of all comment boxes\n  style: &#123;\n    width: 300,\n    height: 100\n  &#125;\n&#125;\n\ncontextMenuoptions.contextMenu : boolean | Array&lt;string&gt; | object\n默认: undefined\n配置ContextMenu插件\n\n\n\nsetting\ndesc\n\n\n\nfalse\n关闭插件\n\n\ntrue\n开启插件并使用默认配置\n\n\narray\n开启插件修改单个上下文菜单\n\n\nobject\n开启插件并应用自定义上下文菜单\n\n\n// enable the `ContextMenu` plugin\n// use the default context menu options\ncontextMenu: true,\n\n// enable the `ContextMenu` plugin\n// and modify individual context menu options\ncontextMenu: ['row_above', 'row_below', '---------', 'undo', 'redo'],\n\n// enable the `ContextMenu` plugin\n// and apply a custom context menu configuration\ncontextMenu: &#123;\n  items: &#123;\n    'option1': &#123;\n      name: 'option1'\n    &#125;,\n    'option2': &#123;\n      name: 'option2',\n      submenu: &#123;\n        items: [\n          &#123;\n            key: 'option2:suboption1',\n            name: 'option2:suboption1',\n            callback: function(key, options) &#123;\n              ...\n            &#125;\n          &#125;,\n          ...\n        ]\n      &#125;\n    &#125;\n  &#125;\n&#125;,\n\ncopyableoptions.copyable : boolean\n默认: true\n单元格的值是否可以被复制\n// enable copying for every cell of the entire grid\ncopyable: true,\n\n// enable copying for individual columns\ncolumns: [\n  &#123;\n    // enable copying for every cell of this column\n    copyable: true\n  &#125;,\n  &#123;\n    // disable copying for every cell of this column\n    copyable: false\n  &#125;\n]\n\n// enable copying for specific cells\ncells: [\n  &#123;\n    cell: 0,\n    row: 0,\n    // disable copying for cell (0, 0)\n    copyable: false,\n  &#125;\n],\n\ncopyPasteoptions.copyPaste : object | boolean\n配置CopyPaste插件\n默认: true\n\n\n\nsetting\ndesc\n\n\n\ntrue\n开启插件使用默认配置\n\n\nfalse\n关闭插件\n\n\nobject\n开启插件并修改配置\n\n\n如果值为object, 则有一下属性:\n\n\n\nprop\ntype\ndesc\n\n\n\ncolumnsLimit\nnumber(default: Infinity)\n最大可复制列数\n\n\nrowsLimit\nnumber(default: Infinity)\n最大可复制行数\n\n\npasteMode\noverwrite\nshift_down\n\n\nuiContainer\nelement\n辅助可聚焦元素的容器\n\n\n// disable the `CopyPaste` plugin\ncopyPaste: false,\n\n// enable the `CopyPaste` plugin\n// and modify the `CopyPaste` plugin options\ncopyPaste: &#123;\n  // set the maximum number of columns that can be copied\n  columnsLimit: 25,\n  // set the maximum number of rows that can be copied\n  rowsLimit: 50,\n  // set the paste behavior\n  pasteMode: 'shift_down',\n  // set the UI container\n  uiContainer: document.body,\n&#125;,\n\ncorrectFormatoptions.correctFormat : boolean\n默认: false\n是否更正日期单元格格式, 如果为true, 则强制使用dateFormat选项\ncolumns: [\n  &#123;\n  // set the `type` of every cell in this column to `date`\n  type: 'date',\n  // for every `date` cell of this column, set the date format to `YYYY-MM-DD`\n  dateFormat: 'YYYY-MM-DD',\n  // enforce the `YYYY-MM-DD` date format\n  correctFormat: true\n  &#125;,\n],\n\ncurrentColClassNameoptions.currentColClassName : string\n默认: undefined\n为当前选中的列的每一个单元格添加类名\ncurrentHeaderClassNameoptions.currentHeaderClassName : string\n默认: ht__highlight\n为当前选中的头添加类名\ncurrentRowClassNameoptions.currentRowClassName : string\n默认: undefined\n为当前选中的行的每一个单元格添加类名\ncustomBordersoptions.customBorders : boolean | Array&lt;object&gt;\n默认: false\n配置CustomBorders插件\n要启用CustomBorders插件并为特定单元格添加预定义的边框:\n\n\n\nprop\nsub-prop\ntype\ndesc\n\n\n\nrow\n-\nnum\n单元格行索引\n\n\ncol\n-\nnum\n单元格列索引\n\n\nleft\nwidth color\nwidth: num  color: string\n设置边框的宽度和颜色\n\n\nright\n同上\n同上\n同上\n\n\ntop\n同上\n同上\n同上\n\n\nbottom\n同上\n同上\n同上\n\n\n要启用CustomBorders插件并在范围单元格添加预定义的边框:\n\n\n\nprop\nsub-prop\ntype\ndesc\n\n\n\nrange\nfrom: {row, col}, to: {row,col}\nrow: num, col: num\n单元格范围\n\n\nleft\nwidth color\nwidth: num  color: string\n设置边框的宽度和颜色\n\n\nright\n同上\n同上\n同上\n\n\ntop\n同上\n同上\n同上\n\n\nbottom\n同上\n同上\n同上\n\n\n\n点击查看示例\n// enable the `CustomBorders` plugin\ncustomBorders: true,\n\n// enable the `CustomBorders` plugin\n// and add a predefined border for a particular cell\ncustomBorders: [\n  // add an object with a border configuration for one cell\n  &#123;\n    // set the cell's row coordinate\n    row: 2,\n    // set the cell's column coordinate\n    col: 2,\n    // set the left border's width and color\n    left: &#123;\n      width: 2,\n      color: 'red'\n    &#125;,\n    // set the right border's width and color\n    right: &#123;\n      width: 1,\n      color: 'green'\n    &#125;,\n    // set the top border's width and color\n    top: '',\n    // set the bottom border's width and color\n    bottom: ''\n  &#125;\n],\n\n// enable the `CustomBorders` plugin\n// and add a predefined border for a range of cells\ncustomBorders: [\n  // add an object with a border configuration for one range of cells\n  &#123;\n    // select a range of cells\n    range: &#123;\n      // set the range's top-left corner\n      from: &#123;\n        row: 1,\n        col: 1\n      &#125;,\n      // set the range's bottom-right corner\n      to: &#123;\n        row: 3,\n        col: 4\n      &#125;\n    &#125;,\n    // set the left border's width and color\n    left: &#123;\n      width: 2,\n      color: 'red'\n    &#125;,\n    // set the right border's width and color\n    right: &#123;&#125;,\n    // set the top border's width and color\n    top: &#123;&#125;,\n    // set the bottom border's width and color\n    bottom: &#123;&#125;\n  &#125;\n],\n\n\n\ndataoptions.data : Array&lt;Array&gt; | Array&lt;object&gt;\n默认: undefined\n设置表格初始数据, 该数据是通过引用绑定至表格, 所以当修改表格中的数据时, 源数据也会被修改\ndataSchemaoptions.dataSchema : object\n默认: undefined\n如果data设置为数组对象或者为空, 则dataSchema会定义新行的结构\n\n点击查看示例\ndata: null,\ndataSchema: &#123;id: null, name: &#123;first: null, last: null&#125;, address: null&#125;,\n\n\n\ndateFormatoptions.dateFormat : string\n默认: DD/MM/YYYY\n设置日期单元格的日期格式\ncolumns: [\n  &#123;\n  // set the `type` of every cell in this column to `date`\n  type: 'date',\n  // for every `date` cell of this column, set the date format to `YYYY-MM-DD`\n  dateFormat: 'YYYY-MM-DD',\n  &#125;,\n],\n\ndatePickerConfigoptions.datePickerConfig : object\n默认: undefined\n配置日期单元格编辑器的日期选择器, 使用外部依赖: Pikaday\n您可以使用任何可用的Pikaday选项将datePickerConfig选项设置为对象，但以下选项除外，这些选项始终会被日期单元格编辑器覆盖:\n\nbound\ncontainer\nfield\ntrigger\n\n如果未定义datePickerConfig选项，日期单元格编辑器还会覆盖以下Pikaday选项\n\nformat ——&gt; DD/MM/YYYY\nreposition ———–&gt; false\n\ndefaultDateoptions.defaultDate : string\n默认: undefined\n配置默认日期\n\n点击查看示例\ncolumns: [\n  &#123;\n    // set the `type` of every cell in this column to `date`\n    type: 'date',\n    // in every empty `date` cell of this column, display `2015-02-02`\n    defaultDate: '2015-02-02'\n  &#125;\n]\n\n\n\ndisableVisualSelectionoptions.disableVisualSelection : boolean | string | Array&lt;string&gt;\n默认: false\n配置如何显示选择\n\n\n\nsetting\ndesc\n\n\n\nfalse\n- 展示单选 -展示范围选择 - 展示头部选择\n\n\ntrue\n- 不展示单选 - 不展示范围选择 - 不展示头部选择\n\n\n‘current’\n- 不展示单个单元格选择 - 展示范围选择 - 展示头部选择\n\n\n‘area’\n- 展示单个选择 - 不展示范围选择 - 展示头部选择\n\n\n‘header&#39;\n- 展示单个单元格选择 - 展示范围选择 - 不展示头部选择\n\n\narray\n结合’current’, ‘area’, 或 ‘header’\n\n\ndragToScrolloptions.dragToScroll : boolean\n默认: true\n配置DragToScroll插件\ndropdownMenuoptions.dropdownMenu : boolean | object | Array&lt;string&gt;\n默认: undefined\n配置DropdownMenu插件\n// enable the `DropdownMenu` plugin\n// use the default context menu options\ndropdownMenu: true,\n\n// enable the `DropdownMenu` plugin\n// and modify individual context menu options\ndropdownMenu: ['row_above', 'row_below', '---------', 'undo', 'redo'],\n\n// enable the `DropdownMenu` plugin\n// and apply a custom dropdown menu configuration\ndropdownMenu: &#123;\n  items: &#123;\n    'option1': &#123;\n      name: 'option1'\n    &#125;,\n    'option2': &#123;\n      name: 'option2',\n      submenu: &#123;\n        items: [\n          &#123;\n            key: 'option2:suboption1',\n            name: 'option2:suboption1',\n            callback(key, options) &#123;\n              ...\n            &#125;\n          &#125;,\n          ...\n        ]\n      &#125;\n    &#125;\n  &#125;\n&#125;,\n\neditoroptions.editor : string | function | boolean\n默认: undefined\n设置单元格编辑器\n\n\n\nAlias\nCell editor function\n\n\n\ncustom alias\n自定义单元格编辑器函数\n\n\nautcomplate\n\n\n\nbase\n\n\n\ncheckbox\n\n\n\ndate\n\n\n\ndropdown\n\n\n\nhandsontable\n\n\n\nnumeric\n\n\n\npassword\n\n\n\nselect\n\n\n\ntext\n\n\n\ntime\n\n\n\n若想禁用编辑功能, 可将editor选项设置为false, 也可设置单元格readOnly为true\n\n点击查看更多\n// use the `numeric` editor for every cell of the entire grid\neditor: 'numeric',\n\n// apply the `editor` option to individual columns\ncolumns: [\n  &#123;\n    // use the `autocomplete` editor for every cell of this column\n    editor: 'autocomplete'\n  &#125;,\n  &#123;\n    // disable editing cells through cell editors for every cell of this column\n    editor: false\n  &#125;\n]\n\n\n\nenterBeginsEditingoptions.enterBeginsEditing : boolean\n默认: true\n配置Enter键作用\n\n\n\nsetting\ndesc\n\n\n\ntrue\n- 按一次, 开始编辑当前单元格 - 按两次, 移动至另一个单元格 - 按照enterMoves配置\n\n\nfalse\n-  按一次,移动至另一个单元格 - 按照enterMoves配置\n\n\nenterMovesoptions.enterMoves : object | function\n默认: &#123;col: 0, row: 1&#125;\n配置Enter键的操作。 如果enterBeginsEditing选项设置为true，则enterMoves设置适用于第二次按Enter键。 如果enterBeginsEditing选项设置为false，则enterMoves设置适用于第一次按Enter键。 可以将enterMoves选项设置为具有以下属性的对象(或返回此类对象的函数):\n\n\n\nsetting\ntype\ndesc\n\n\n\ncol\nnum\n- 按下enter, 向右移动选择列 - 按下shift + enter, 向左移动选择列\n\n\nrow\nnum\n- 按下enter, 向下移动选择行 - 按下shift + enter, 向右移动选择列\n\n\n\n点击查看更多\n// on pressing Enter, move selection 1 column right and 1 row down\n// on pressing Shift+Enter, move selection 1 column left and 1 row up\nenterMoves: &#123;col: 1, row: 1&#125;,\n\n// the same setting, as a function\n// `event` is a DOM Event object received on pressing Enter\n// you can use it to check whether the user pressed Enter or Shift+Enter\nenterMoves(event) &#123;\n  return &#123;col: 1, row: 1&#125;;\n&#125;,\n\n\n\nfillHandleoptions.fillHandle : boolean | string | object\n默认: true\n配置Autofill插件\n\n\n\nsetting\nsub-setting\ndesc\n\n\n\ntrue\n\n- 开启插件 - 添加填充\n\n\nfalse\n\n关闭插件\n\n\n‘vertical’\n\n- 开启插件 - 垂直填充\n\n\n‘horizontal’\n\n- 开启插件 - 水平填充\n\n\nobject\n{autoInsertRow: true(default) | false, direction: ‘vertical ‘| ‘horizontal’}\n- 开启插件 - 添加填充 - 配置选项\n\n\nfilteroptions.filter : boolean\n默认: true\n当单元格编辑器类型为autocomplete时是否更新用户的输入\nfilteringCaseSensitiveoptions.filteringCaseSensitive : boolean\n默认: false\n当单元格编辑器类型为autocomplete时是否区分输入的大小写\nfiltersoptions.filters : boolean\n默认: undefined\n是否开启Filters插件\nfixedColumnsLeftoptions.fixedColumnsLeft : number\n默认: 0\n设置左侧固定列\nfixedRowsBottomoptions.fixedColumnsLeft : number\n默认: 0\n设置底部固定行\nfixedRowsTopoptions.fixedColumnsLeft : number\n默认: 0\n设置顶部固定行\nformulasoptions.formulas : object\n默认: undefined\n配置Formulas插件\n\n点击查看更多\n// either add the `HyperFormula` class\nformulas: &#123;\n  // set `engine` to `HyperFormula`\n  engine: HyperFormula,\n  sheetId: 1,\n  sheetName: 'Sheet 1'\n&#125;\n\n// or, add a HyperFormula instance\n// initialized with the `'internal-use-in-handsontable'` license key\nconst hyperformulaInstance = HyperFormula.buildEmpty(&#123;\n  licenseKey: 'internal-use-in-handsontable',\n&#125;);\n\nformulas: &#123;\n  // set `engine` to a HyperFormula instance\n  engine: hyperFormulaInstance,\n  sheetId: 1,\n  sheetName: 'Sheet 1'\n&#125;\n\n// or, add a HyperFormula configuration object\nformulas: &#123;\n  // set `engine` to a HyperFormula configuration object\n  engine: &#123;\n    hyperformula: HyperFormula // or `engine: hyperFormulaInstance`\n    leapYear1900: false,       // this option comes from HyperFormula\n    // add more HyperFormula configuration options\n  &#125;,\n  sheetId: 1,\n  sheetName: 'Sheet 1'\n&#125;\n\n// use the same HyperFormula instance in multiple Handsontable instances\n\n// a Handsontable instance `hot1`\nformulas: &#123;\n  engine: HyperFormula,\n  sheetId: 1,\n  sheetName: 'Sheet 1'\n&#125;\n\n// a Handsontable instance `hot2`\nformulas: &#123;\n  engine: hot1.getPlugin('formulas').engine,\n  sheetId: 1,\n  sheetName: 'Sheet 1'\n&#125;\n\n\n\nfragmentSelectionoptions.fragmentSelection : boolean | string\n默认: false\n配置文本选择设置\n\n\n\nsetting\ndesc\n\n\n\nfalse\n关闭文本选择\n\n\ntrue\n一次在多个单元格中启用文本选择\n\n\n‘cell’\n一次在一个单元格中启用文本选择\n\n\nheightoptions.height : number | string | function\n默认: undefined\n设置表格高度\n// set the grid's height to 500px\nheight: 500,\n\n// set the grid's height to 75vh\nheight: '75vh',\n\n// set the grid's height to 500px, using a function\nheight() &#123;\n  return 500;\n&#125;,\n\nhiddenColumnsoptions.hiddenColumns : boolean | object\n默认: undefined\n配置HiddenColumns插件\n\n\n\nsetting\ndesc\n\n\n\nfalse\n关闭插件\n\n\ntrue\n开启插件并使用默认插件配置\n\n\nobject\n- 开启插件 - 修改默认配置\n\n\n如果为object, 则有一下属性\n\n\n\nprop\ntype\ndesc\n\n\n\ncolums\narr\n初始化时隐藏的列的索引\n\n\ncopyPasteEnabled\nboolean\n复制粘贴时, 是否考虑隐藏列\n\n\nindicators\nboolean\n显示标记, 是否指示隐藏列的存在\n\n\nhiddenRows同hiddenColumns\ninvalidCellClassNameoptions.invalidCellClassName : string\n默认: htInvalid\n为单元格验证器验证失效的单元格添加类名\nlabeloptions.label : object\n默认: undefined\n为复选框单元格配置label\n\n\n\nprop\nvalue\ndesc\n\n\n\nposition\nafter(default)\nbefore\n\n\nvalue\nstring | function\n标签文字\n\n\nseparated\nfalse (default)\ntrue\n\n\nproperty\nstring\n-用作标签文本的数据对象属性名称 -仅当数据选项设置为对象数组时有效\n\n\nlanguageoptions.language : string\n默认 : en-us\n设置语言\nlicenseKeyoptions.licenseKey : string\n默认: undefined\n许可证\nlocaleoptions.locale : string\nmanualColumnFreezeoptions.manualColumnFreeze : boolean\n默认: undefined\n配置manualColumnFreeze插件\nmanualColumnMoveoptions.manualColumnMove : boolean | Array&lt;number&gt;\n默认: undefined\n配置manualColumnMove插件\n\n点击查看示例\n// enable the `ManualColumnMove` plugin\nmanualColumnMove: true,\n\n// enable the `ManualColumnMove` plugin\n// at initialization, move column 0 to 1\n// at initialization, move column 1 to 4\n// at initialization, move column 2 to 6\nmanualColumnMove: [1, 4, 6],\n\n\n\nmanualColumnResizeoptions.manualColumnResize : boolean | Array&lt;number&gt;\n默认: undefined\n配置manualColumnResize插件\n\n点击查看示例\n// enable the `manualColumnResize` plugin\nmanualColumnResize: true,\n\n// enable the `manualColumnResize` plugin\n// set the initial width of column 0 to 40 pixels\n// set the initial width of column 1 to 50 pixels\n// set the initial width of column 2 to 60 pixels\nmanualColumnResize: [40, 50, 60],\n\n\n\nmanualRowMoveoptions.manualRowMove : boolean | Array&lt;number&gt;\n默认: undefined\n\n点击查看示例\n// enable the `ManualRowMove` plugin\nmanualRowMove: true,\n\n// enable the `ManualRowMove` plugin\n// at initialization, move row 0 to 1\n// at initialization, move row 1 to 4\n// at initialization, move row 2 to 6\nmanualColumnMove: [1, 4, 6],\n\n\n\nmanualRowResizeoptions.manualRowResize : boolean | Array&lt;number&gt;\n默认: undefined\n\n点击查看示例\n// enable the `ManualRowResize` plugin\nmanualColumnResize: true,\n\n// enable the `ManualRowResize` plugin\n// set the initial height of row 0 to 40 pixels\n// set the initial height of row 1 to 50 pixels\n// set the initial height of row 2 to 60 pixels\nmanualColumnResize: [40, 50, 60],\n\n\n\nmaxColsoptions.maxCols : number\n默认: Infinity\n设置最大列数\nminColsoptions.maxCols : number\n默认: 0\n设置最小列数\nmaxRowsoptions.maxRows : number\n默认: Infinity\n设置最大行数\nminRowsoptions.maxCols : number\n默认: 0\n设置最小行数\nmergeCellsoptions.mergeCells : boolean | Array&lt;object&gt;\n默认: false\n配置MergeCells插件\n当为Array时, 需要有row,col,rowspan,colspan\n\n示例\n// enable the `MergeCells` plugin\nmargeCells: true,\n\n// enable the `MergeCells` plugin\n// and merge specific cells at initialization\nmergeCells: [\n  // merge cells from cell (1,1) to cell (3,3)\n  &#123;row: 1, col: 1, rowspan: 3, colspan: 3&#125;,\n  // merge cells from cell (3,4) to cell (2,2)\n  &#123;row: 3, col: 4, rowspan: 2, colspan: 2&#125;,\n  // merge cells from cell (5,6) to cell (3,3)\n  &#123;row: 5, col: 6, rowspan: 3, colspan: 3&#125;\n],\n\n\n\nminSpareColsoptions.minSpareCols : number\n默认: 0\n设置表格右端最小空列数量\nminSpareRowsoptions.minSpareRows : number\n默认: 0\n设置表格底部最小空行数量\nmultiColumnSortingoptions.multiColumnSorting : boolean | object\n默认: undefined\n配置MultiColumnSorting插件\n\n点击查看示例\n// enable the `MultiColumnSorting` plugin\nmultiColumnSorting: true\n\n// enable the `MultiColumnSorting` plugin with custom configuration\nmultiColumnSorting: &#123;\n  // sort empty cells as well\n  sortEmptyCells: true,\n  // display an arrow icon in the column header\n  indicator: true,\n  // disable clicking on the column header to sort the column\n  headerAction: false,\n  // add a custom compare function\n  compareFunctionFactory(sortOrder, columnMeta) &#123;\n    return function(value, nextValue) &#123;\n      // some value comparisons which will return -1, 0 or 1...\n    &#125;\n  &#125;\n&#125;\n\n// enable the `MultiColumnSorting` plugin\nmultiColumnSorting: &#123;\n  // at initialization, sort column 1 in ascending order\n  initialConfig: &#123;\n    column: 1,\n    sortOrder: 'asc'\n  &#125;,\n  // at initialization, sort column 2 in descending order\n  initialConfig: &#123;\n    column: 2,\n    sortOrder: 'desc'\n  &#125;\n&#125;\n\n\n\nnestedHeadersoptions.nestedHeaders : Array&lt;Array&gt;\n默认; undefined\n配置NestedHeaders插件\n\n点击查看示例\nnestedHeaders: [\n  ['A', &#123;label: 'B', colspan: 8&#125;, 'C'],\n  ['D', &#123;label: 'E', colspan: 4&#125;, &#123;label: 'F', colspan: 4&#125;, 'G'],\n  ['H', 'I', 'J', 'K', 'L', 'M', 'N', 'R', 'S', 'T']\n],\n\n\n\nnestedRowsoptions.nestedRows : boolean\n默认: false\n配置NestedRows插件\nnoWordWrapClassNameoptions.noWordWrapClassName : string\n默认: htNoWrap\n为wordWrap设置为false的单元格添加类名\nnumericFormatoptions.numericFormat : object\n默认: undefined\n配置数字单元格显示的数字格式\n\n点击查看示例\ncolumns: [\n  &#123;\n    // set the `type` of every cell in this column to `numeric`\n    type: 'numeric',\n    // set the `numericFormat` option for every `numeric` cell of this column\n    numericFormat: &#123;\n      // set the number format\n      pattern: '0,00',\n      // set the currency format\n      culture: 'en-US'\n    &#125;\n  &#125;\n],\n\n\n\n","slug":"Handsontbale-Option","date":"2022-04-25T06:52:01.000Z","categories_index":"","tags_index":"Handsontable","author_index":"王磊磊"},{"id":"930433a2aa2ccb355dd043d32b2d1e6f","title":"介绍几种获取IP地址的办法","content":"\n\n\n&lt;script>\n      function getIpAddress(ipAddress) &#123;\n          console.log(ipAddress);\n            / **\n            &#123;\n               addr: \"xxxxxx 电信\",\n               city: \"xx市\",\n               cityCode: \"610100\",\n               err: \"\",\n               ip: \"xxx.xx.xx.xx\",\n               pro: \"xx省\",\n               proCode: \"xxx\",\n               region: \"\",\n               regionCode: \"0\",\n               regionNames: \"\"\n            &#125;\n            */\n      &#125;\n// whois.pconline.com 这个里边还有其他获取Ip的方式, 多种多样\n &lt;/script>\n &lt;script src=\"http://whois.pconline.com.cn/ipJson.jsp?callback=getIpAddress\">&lt;/script>\n\n\n\n\n&lt;script src=\"https://pv.sohu.com/cityjson?ie=utf-8\">&lt;/script>\n搜狐的获取ip的APi, 会在window上挂一个returnCitySN对象\n\n&#123;cip: 'xx.xx.xx.xx', cid: 'xxx', cname: 'xx省xx市'&#125;\n\n\n\n\n// http://ip.42.pl/raw\n// https://httpbin.org/ip\n\n\n","slug":"获取Ip地址","date":"2022-04-22T07:12:24.000Z","categories_index":"","tags_index":"IP","author_index":"王磊磊"},{"id":"0ec6ac22eb0a1a33ab8b12196d865f60","title":"Handsontable-Hooks","content":"Handsontable All Hooks\n\n\n\n\n\n温馨提示\n​    英语水平师从谷歌翻译, 再加上自己的理解产出此文, 如有错误望客官指出, 蟹蟹\n\n\nMembers\nafterAddChildafterAddChild(parent, element, index)\n在向NestedRows结构添加子级后由NestedRows插件触发。当Options#nestedRows选项启用时，将触发此Hook。\n\n\n\nParam\nType\nDesc\n\n\n\nparent\nobject\n父对象\n\n\nelement\nobject | undefined\n作为子元素添加的元素。如果是undefined，则添加一个空白子级。\n\n\nindex\nnumber | undefined\n在父级中的索引, 不传则在父级末尾添加\n\n\nbeforeAddChildbeforeAddChild(parent, element, index)\n比afterAddChild触发早, 参数相同\nafterDetachChildafterDetachChild(parent, element, finalElementPosition)\n父级分离子集后由插件(NestedRows)触发\n\n\n\nParam\nType\nDesc\n\n\n\nparent\nobject\n父级对象\n\n\nelement\nobject\n分离的元素\n\n\nfinalElementPosition\nnum\n分离元素的最后一行索引\n\n\nbeforeDetachChildbeforeDetachChild(parent, element)\n父级分离子集前由插件(NestedRows)触发, 参数同上\n\nafterAutofillafterAutofill(fillData, sourceRange, targetRange, direction)\n自动填充数据之后触发,需要在option中开启fillHandle\n\n\n\nParam\nType\nDesc\n\n\n\nfillData\nArray&lt;Array&gt;\n填充的数据,如果在beforeAutofill中有返回值, 则为返回的数据\n\n\nsourceRange\nCellRange\n起始值的范围\n\n\ntargetRange\nCellRange\n填充区域的范围\n\n\ndirection\nstring\n填充的方向, up,down,left,right\n\n\nbeforeAutofillbeforeAutofill(selectionData, sourceRange, targetRange, direction) ⇒ boolean | Array&lt;Array&gt;\n自动填充数据之前触发, 参数与afterAutofill一致, 返回值决定了afterAutofill中第一个参数的值\nbeforeAutofillInsidePopulatebeforeAutofillInsidePopulate(index, direction, input, deltas)\n数据填充过程中触发\n\n\n\n\n\n\n\n注意\n不推荐的方法\n\n\nmodifyAutofillRangemodifyAutofillRange(startArea, entireArea)\n在设置自动填充范围后由插件(Autofill)触发。需开启option的fillHandle选项\n\nafterBeginEditingafterBeginEditing(row, column)\n开始修改后触发, 参数是单元格的行索引和列索引\n\nafterCellMetaResetafterCellMetaReset()\n重置单元格的meta后触发.调用updateSetting时也会触发\nafterSetCellMetaafterSetCellMeta(row, column, key, value)\n单元格meta改变后触发\nbeforeSetCellMetabeforeSetCellMeta(row, column, key, value) ⇒ * | boolean\n单元格meta改变前触发, 返回false则停止\nafterSetDataAtCellafterSetDataAtCell(changes, [source])\n单元格数据改变后触发\nafterRemoveCellMetaafterRemoveCellMeta(row, column, key, value)\n移除单元格meta后触发    \nbeforeRemoveCellMetabeforeRemoveCellMeta(row, column, key, value) ⇒ * | boolean\n移除单元格meta数据前触发, 返回false则停止\nafterSetDataAtRowPropafterSetDataAtRowProp(changes, [source])\n单元格数据改变后触发, 仅在setDataAtRowProp时可用\nafterSetSourceDataAtCellafterSetSourceDataAtCell(changes, [source])\n单元格数据改变时触发\n\nbeforeChangebeforeChange(changes, [source]) =&gt; void | boolean\n一个或多个单元格更改之前触发, 参数同afterChange, 当返回false时, 取消更改\nbeforeChangeRenderbeforeChangeRender(changes, [source])\n在修改后, 渲染前触发\nafterChangeafterChange(changes, [source])\n单个或多个单元格数据更改后 或者 调用API,例如 setDataAtCell() 后触发| Param    | Type          | Desc                                                 || ——– | ————- | —————————————————- || changes  | Array&lt;Array&gt; | [[row, prop, oldVal, newVal], …]                   || [source] | string        | 数据更新方式, 当source为loadData时,changes为null |\n\nafterColumnMoveafterColumnMove(movedColumns, finalIndex, dropIndex, movePossible, orderChanged)\n拖动列顺序后触发\n\n\n\nParam\nType\nDesc\n\n\n\nmovedColumns\nArray\n由移动的列的索引组成的数组\n\n\nfinalIndex\nnumber\n列索引，是已移动列的起始索引。指向移动动作后元素将被放置的位置\n\n\ndropIndex\nnumber | undefined\n可视列索引，是已移动列的索引。指向我们将要放置移动元素的位置。当没有调用dragColumns函数时，它是undefined\n\n\nmovePossible\nBoolean\n是否可以将列移动到所需位置。\n\n\norderChanged\nBoolean\n是否改变了列顺序\n\n\nbeforeColumnMovebeforeColumnMove(movedColumns, finalIndex, dropIndex, movePossible) ⇒ void | boolean\n拖动列顺序前触发, 如果返回false, 则停止.\nafterRowMoveafterRowMove(movedRows, finalIndex, dropIndex, movePossible, orderChanged)\n移动行之后触发\nbeforeRowMovebeforeRowMove(movedRows, finalIndex, dropIndex, movePossible) ⇒ * | boolean\n移动行之前触发, 返回 false则停止\n\nafterColumnResize改变列宽度后触发\nbeforeColumnResize改变列宽度之前由插件(ManualColumnResize)触发, 须在option中开始manualColumnResize\nafterRowResizeafterRowResize(newSize, row, isDoubleClick)\n改变行大小后触发\nbeforeRowResizebeforeRowResize(newSize, row, isDoubleClick) ⇒ number\n改变行大小之前触发, 返回number 如需自动计算则可不指定返回值\n\nafterColumnCollapse合并列之前触发\nbeforeColumnCollapse合并列之后触发\n\nafterColumnExpand展开列之前触发\nbeforeColumnExpand展开列之后触发\n\nafterColumnSort列排序之前触发\nbeforeColumnSort列排序之后触发\n\nafterContextMenuDefaultOptions每次打开ContextMenu并设置上下文菜单的默认选项后激发\nafterContextMenuHide上下文菜单隐藏后触发\nbeforeContextMenuShow上下文菜单隐藏前触发\nbeforeContextMenuSetItems在设置上下文菜单之前, 但在用户过滤选项之后\n\nafterCopyafterCopy(data, coords)\n复制数据到剪切板后触发,需要在option中开启copyPaste\n\n\n\nParam\nType\nDesc\n\n\n\ndata\nArray\n复制的数据\n\n\ncoords\nArray&lt;Object&gt;\n[ {startRow, startCol, endRow, endCol} ]\n\n\nbeforeCopybeforeCopy(data, coords)\n复制数据之前触发, 参数同afterCopy, 返回fasle则取消复制\nafterPasteafterPaste(data, coords)\n粘贴后触发, 参数同afterCopy\nbeforePastebeforePaste(data, coords)\n粘贴前触发, 参数同上, 返回false则取消粘贴\nafterCutafterCut(data, coords)\n剪切后触发, 参数同上\nbeforeCutbeforeCut(data, coords)\n剪切前触发, 参数同上, 返回false则取消剪切\nafterCopyLimitafterCopyLimit(selectedRows, selectedColumns, copyRowsLimit, copyColumnsLimit)\n复制数据达到限制后触发\n\n\n\nParam\nType\nDesc\n\n\n\nselectedRows\nnum\n所选择的行数\n\n\nselectedColumns\nnum\n所选择的列数\n\n\ncopyRowsLimit\nnum\n最大可复制的行数\n\n\ncopyColumnsLimit\nnum\n最大可复制的列数\n\n\n\nafterCreateColafterCreateCol(index, amount, [source])\n创建新列之后触发\nafterCreateRowafterCreateRow(index, amount, [source])\n创建新行之后触发, 参数类似与afterCreateCol\nbeforeCreateColbeforeCreateCol(index, amount, [source]) ⇒\n创建新列之前触发, 返回false则取消新建\nbeforeCreateRowbeforeCreateRow(index, amount, [source]) ⇒ * | boolean\n创建新行之前触发, 返回false则取消新建\nafterRemoveColafterRemoveCol(index, amount, physicalColumns, [source])\n移除一列或者多列之后触发\nafterRemoveRowafterRemoveRow(index, amount, physicalRows, [source])\n移除一行或者多行之后触发\nbeforeRemoveColbeforeRemoveCol(index, amount, physicalColumns, [source]) ⇒ * | boolean\n移除一列或者多列之前触发, 返回false则停止移除\nbeforeRemoveRowbeforeRemoveRow(index, amount, physicalRows, [source]) ⇒ * | boolean\n移除一行或者多行之前触发, 返回false则停止移除\n\n\n\nParam\nType\nDesc\n\n\n\nindex\nnum\n新建的列索引\n\n\namount\nnum\n新建的列数\n\n\nsource\nstring\n\n\n\n\nafterDeselectafterDeselect\n取消选中单元格后触发\n\nafterInitafterInit\n在实例初始化完成后触发\nbeforeInitbeforeInit\n实例初始化之前触发\nafterDestroyafterDestroy\n销毁实例后触发\n\nafterLanguageChangeafterLanguageChange(languageCode)\n更改了语言后触发\nbeforeLanguageChangebeforeLanguageChange(languageCode)\n更改语言前触发\n\nafterListenafterListen\n在表切换到监听模式后激发。这使得Handsontable能够捕捉键盘事件，并以正确的方式做出响应。\nafterUnlistenafterUnlisten\n监听模式关闭后触发\n\nafterLoadDataafterLoadData(sourceData, initialLoad, source)\n在loadData()或者updateSettings()方法更新数据后触发\nbeforeLoadDatabeforeLoadData(sourceData, initialLoad, source) ⇒ Array\n在loadData()或者updateSettings()方法更新数据后触发, 在afterLoadData之前, 返回的数据将作为表格的新数据\nafterUpdateDataafterUpdateData(sourceData, initialLoad, source)\n在updateData()更新数据之后触发\nbeforeUpdateDatabeforeUpdateData(sourceData, initialLoad, source) ⇒ Array\n在updateData()更新数据之前触发, 返回的数据将作为表格的新数据\n\n\n\nParam\nType\nDesc\n\n\n\nsourceData\nArray\n加载的数据\n\n\ninitialLoad\nboolean\n表示数据是在初始化时加载的还是稍后加载\n\n\nsource\nstring\n\n\n\nafterUpdateSettingsafterUpdateSettings(newSettings)\n更新配置后触发\n\nafterDocumentKeyDownafterDocumentKeyDown(event)\n捕获附加到文档主体的keydown事件的通用钩子。这些事件被委托给Hooks,由Core和内部模块(如插件、编辑器)使用。参数为keyDown事件对象\nafterDrawSelectionafterDrawSelection(currentRow, currentColumn, cornersOfSelection, layerLevel) ⇒ string | undefined\n\nafterDropdownMenuDefaultOptionsafterDropdownMenuDefaultOptions(predefinedItems)\n由DropdownMenu插件在设置下拉菜单的默认选项后触发。这些选项是一个集合，用户可以通过在Options的 dropdownMenu选项中设置一个键数组或一个对象数组来选择。\nafterDropdownMenuHideafterDropdownMenuHide(instance)\n下拉菜单隐藏后, 由插件(DropdownMenu)触发, 需要在option中开启dropDownMeny,参数为dropDownMenu实例\nafterDropdownMenuShowafterDropdownMenuHide(dropdownMenu)\n下拉菜单打开后, 由插件(DropdownMenu)触发, 需要在option中开启dropDownMeny,参数为dropDownMenu实例\nbeforeDropdownMenuShowbeforeDropdownMenuShow(dropdownMenu)\n下拉菜单打开前,由插件(DropdownMenu)触发\nbeforeDropdownMenuSetItemsbeforeDropdownMenuSetItems(menuItems)\n由DropdownMenu插件在设置下拉菜单的选项之前但在用户过滤这些选项之后触发(Dropdown Menu)。这个hook有助于确定用户是否使用指定的菜单项，或者将某个菜单项设置为总是可见。\n\nafterFilterafterFilter(conditionsStack)\n过滤后触发, 参数是一个有条件的数组对象 Array&lt;object&gt;\nbeforeFilterbeforeFilter(conditionsStack) ⇒ boolean\n过滤前触发, 返回false则过滤不会呈现于UI\n\nafterFormulasValuesUpdateafterFormulasValuesUpdate(changes)\n引擎中的值更新时\n\n\n\nParam\nType\nDesc\n\n\n\nchanges\nArray\n更改的值和位置\n\n\n\nafterGetCellMetaafterGetCellMeta(row, column, cellProperties)\n获取单元格设置后触发\nbeforeGetCellMetabeforeGetCellMeta(row, column, cellProperties)\n获取单元格设置前触发, 参数同上\n\n\n\nParam\nType\nDesc\n\n\n\nrow\nnum\n行索引\n\n\ncolumn\nnum\n列索引\n\n\ncellProperties\nobject\n单元格设置对象\n\n\n\nafterGetColHeaderafterGetColHeader(column, TH)\n获取列头\nafterGetColumnHeaderRenderersafterGetColumnHeaderRenderers(renderers)\n获取列头的渲染器\nafterGetRowHeaderafterGetRowHeader(row, TH)\n获取行头\nafterGetRowHeaderRenderersafterGetRowHeaderRenderers(renderers)\n获取行头渲染器\n\nafterHideColumnsafterHideColumns(currentHideConfig, destinationHideConfig, actionPossible, stateChanged)\n在插件(HiddenColumns)将列隐藏后触发,需在option中开启hiddenColumns\nbeforeHideColumnsbeforeHideColumns(currentHideConfig, destinationHideConfig, actionPossible) ⇒ undefined | boolean\n在插件(HiddenColumns)将列隐藏前触发,需在option中开启hiddenColumns, 如果返回false,则取消隐藏\nafterHideRowsafterHideRows(currentHideConfig, destinationHideConfig, actionPossible, stateChanged)\n在插件(HiddenColumns)将行隐藏后触发,需在option中开启hiddenColumns\nbeforeHideRowsbeforeHideRows(currentHideConfig, destinationHideConfig, actionPossible) ⇒ undefined | boolean\n在插件(HiddenColumns)将列隐藏行触发,需在option中开启hiddenColumns, 如果返回false,则取消隐藏\nafterUnhideColumnsafterUnhideColumns(currentHideConfig, destinationHideConfig, actionPossible, stateChanged)\n由插件(HiddenColumns)在取消隐藏列后触发, 需在option中开启hiddenColumns\nbeforeUnhideColumnsbeforeUnhideColumns(currentHideConfig, destinationHideConfig, actionPossible) ⇒ undefined | boolean\n由插件(HiddenColumns)在取消隐藏列前触发, 需在option中开启hiddenColumns, 返回false则停止\nafterUnhideRowsafterUnhideRows(currentHideConfig, destinationHideConfig, actionPossible, stateChanged)\n由插件(HiddenColumns)在取消隐藏行后触发, 需在option中开启hiddenColumns\nbeforeUnhideRowsbeforeUnhideRows(currentHideConfig, destinationHideConfig, actionPossible) ⇒ undefined | boolean\n由插件(HiddenColumns)在取消隐藏行前触发, 需在option中开启hiddenColumns,返回false则停止\n\n\n\nParam\nType\nDesc\n\n\n\ncurrentHideConfig\nArray\n当前隐藏配置\n\n\ndestinationHideConfig\nArray\n目标隐藏配置\n\n\nactionPossible\nboolean\n提供的索引是否有效\n\n\nstateChanged\nboolean\n是否影响了其他非隐藏列\n\n\n\nafterMergeCellsafterMergeCells(cellRange, mergeParent, [auto])\n单元格合并后由插件(MergeCells)触发, 需在option中开启mergeCells\nbeforeMergeCellsbeforeMergeCells(cellRange, [auto])\n单元格合并之前触发\nafterUnmergeCellsafterUnmergeCells(cellRange, [auto])\n取消合并单元格之后触发\nbeforeUnmergeCellsbeforeUnmergeCells(cellRange, [auto])\n取消合并单元格之前触发\n\n\n\nParam\nType\nDesc\n\n\n\ncellRange\nCellRange\n合并的区域\n\n\nmergeParent\nobject\n合并区域的父集合\n\n\nauto\nboolean\n是否由插件自动合并\n\n\n\nafterModifyTransformEndafterModifyTransformEnd(coords, rowTransformDir, colTransformDir)\nafterModifyTransformStartafterModifyTransformStart(coords, rowTransformDir, colTransformDir)\n\nafterMomentumScrollafterMomentumScroll()\n\nafterNamedExpressionAddedafterNamedExpressionAdded(namedExpressionName, changes)\n在命名表达式被添加到公式引擎实例后调用\nafterNamedExpressionRemovedafterNamedExpressionRemoved(namedExpressionName, changes)\n在命名表达式被从公式引擎实例移除后调用\n\n\n\nParam\nType\nDesc\n\n\n\nnamedExpressionName\nstring\n表达式名称\n\n\nchanges\nArray\n改变的值和位置\n\n\n\nafterOnCellContextMenuafterOnCellContextMenu(event, coords, TD)\n在单元格或者行头/列头上单击右键后触发\nbeforeOnCellContextMenubeforeOnCellContextMenu(event, coords, TD)\n在单元格或者行头/列头上单击右键触发, 但是在相关计算之前, 如果右键选中的是一个区域, 则 coords为选中的最后一个单元格信息\nafterOnCellMouseDownafterOnCellMouseDown(event, coords, TD)\n鼠标在单元格上按下之后触发(左右中键都可)\nbeforeOnCellMouseDownbeforeOnCellMouseDown(event, coords, TD, controller)\n鼠标在单元格上按下之后触发, (左右中键都可)但在相关计算之前触发\nafterOnCellMouseUpafterOnCellMouseUp(event, coords, TD)\n鼠标在单元格上抬起之后触发\nbeforeOnCellMouseUpbeforeOnCellMouseUp(event, coords, TD)\n鼠标在单元格上抬起之后触发, 但在相关计算之前\nafterOnCellMouseOverafterOnCellMouseOver(event, coords, TD)\n鼠标移入单元格之后触发\nbeforeOnCellMouseOverbeforeOnCellMouseOver(event, coords, TD, controller)\n鼠标移入单元格之后, 但在相关计算之前触发\nafterOnCellMouseOutafterOnCellMouseOut(event, coords, TD)\n鼠标移出单元格后触发\nbeforeOnCellMouseOutbeforeOnCellMouseOut(event, coords, TD)\n鼠标移出单元格之后. 但在相关计算之前触发\n\n\n\nParam\nType\nDesc\n\n\n\nevent\nEvent\n点击事件信息\n\n\ncoords\nCellCoords\n单元格位置对象\n\n\nTD\nelement\n点击元素\n\n\ncontroller\nobject\n\n\n\n\nafterPluginsInitializedafterPluginsInitialized()\n在所有插件初始化之后触发, 这个hook必须在HandsonTable初始化之前添加\nHandsonTable.hooks.add('afterPluginsInitialized', () => &#123;&#125;)\n\n\nafterRedoafterRedo(action)\n恢复后触发, 需在option中开启undo\nbeforeRedobeforeRedo(action) ⇒ * | boolean\n恢复前触发, 返回false则停止恢复\nafterUndoafterUndo(action)\n在撤销后由插件(UndoRedo)触发, 参数是一个动作对象\nbeforeUndobeforeUndo(action)\n在撤销后由插件(UndoRedo)触发, 参数是一个动作对象, 返回false则停止撤销\nafterRedoStackChangeafterRedoStackChange(undoneActionsBefore, undoneActionsAfter)\n在UndoRedo插件改变恢复栈后触发\nbeforeRedoStackChangebeforeRedoStackChange(undoneActions)\n在UndoRedo插件改变恢复栈前触发\nafterUndoStackChangeafterUndoStackChange(doneActionsBefore, doneActionsAfter)\n在UndoRedo插件改变撤销栈后触发, 参数类似于afterRedoStackChange\nbeforeUndoStackChangebeforeUndoStackChange(doneActionsBefore, doneActionsAfter)\n在UndoRedo插件改变撤销栈前触发, 参数类似于afterRedoStackChange, 返回false则停止操作\n\n\n\nParam\nType\nDesc\n\n\n\nundoneActionsBefore\nArray\n操作之前的恢复栈数据\n\n\nundoneActionsAfter\nArray\n操作之后的恢复栈数据\n\n\n\nafterRefreshDimensionsafterRefreshDimensions(previousDimensions, currentDimensions, stateChanged)\n窗口大小改变后触发\nbeforeRefreshDimensionsbeforeRefreshDimensions(previousDimensions, currentDimensions, actionPossible) ⇒ undefined | boolean\n如果返回false. 则不会刷新, afterRefreshDimensions也不会执行\n\n\n\nParam\nType\nDesc\n\n\n\npreviousDimensions\nobject\n改变前的窗口大小\n\n\ncurrentDimensions\nobject\n改变后的窗口大小\n\n\nstateChanged\nBoolean\n表格是否被重新渲染\n\n\nafterViewRenderafterViewRender(isForced)\n在表格宽高改变后触发\n\n\n\n\n\n\n提示\n在9.x和更早的版本, afterViewRender名字是afterRender\n\n\nbeforeViewRenderbeforeViewRender(isForced, skipRender)\n在表格宽高改变前触发\n\n\n\n\n\n\n提示\n在9.x和更早的版本, beforeViewRender 名字是beforeRenderr\n\n\nafterRenderafterRender(isForced)\n表格渲染完成后触发\nbeforeRenderbeforeRender(isForced)\n表格渲染完成前触发\nafterRendererafterRenderer(TD, row, column, prop, value, cellProperties)\n单元格渲染完成之后触发\nbeforeRendererbeforeRenderer(TD, row, column, prop, value, cellProperties)\n单元格渲染完成之前触发\n\nafterScrollHorizontallyafterScrollHorizontally\n水平滚动后触发\nafterScrollVerticallyafterScrollVertically\n垂直滚动后触发\nbeforeTouchScrollbeforeTouchScroll\n在触摸设备上, 触摸开始滚动前触发\n\nafterSelectionafterSelection(row, column, row2, column2, preventScrolling, selectionLayerLevel)\n选中一个或者多个单元格触发\nafterSelectionByPropafterSelectionByProp(row, prop, row2, prop2, preventScrolling, selectionLayerLevel)\n选中一个或者多个单元格触发\n参数与afterSelection差不多, 只是将col替换为prop\nafterSelectionEndafterSelectionEnd(row, column, row2, column2, selectionLayerLevel)\n选中一个或多个单元格之后(结束选中)触发\nafterSelectionEndByPropafterSelectionEndByProp(row, prop, row2, prop2, selectionLayerLevel)\n选中一个或多个单元格之后(结束选中)触发\n\n\n\nParam\nType\nDesc\n\n\n\nrow\nnum\n选中起始行\n\n\ncolumn\nnum\n选中起始列\n\n\nrow2\nnum\n选中结束行\n\n\ncolumn2\nnum\n选中结束列\n\n\npreventScrolling\nobject\n具有value的对象, 观察值的变化\n\n\nselectionLayerLevel\nnum\n当前选中的层级\n\n\n\n\nafterSheetAddedafterSheetAdded(addedSheetDisplayName)\n从Formulas实例中添加新的表时触发\nafterSheetRemovedafterSheetRemoved(removedSheetDisplayName, changes)\n从Formulas实例中移除表时触发\nafterSheetRenamedafterSheetRenamed(oldDisplayName, newDisplayName)\n从Formulas实例中更改表的名称触发\n\nafterTrimRowafterTrimRow(currentTrimConfig, destinationTrimConfig, actionPossible, stateChanged) ⇒ undefined | boolean\nafterUntrimRowafterUntrimRow(currentTrimConfig, destinationTrimConfig, actionPossible, stateChanged) ⇒ undefined | boolean\nbeforeTrimRowbeforeTrimRow(currentTrimConfig, destinationTrimConfig, actionPossible) ⇒ undefined | boolean\nbeforeUntrimRowbeforeUntrimRow(currentTrimConfig, destinationTrimConfig, actionPossible) ⇒ undefined | boolean\n\nafterValidateafterValidate(isValid, value, row, prop, [source]) ⇒ void | boolean\n定义了验证器函数, 并在验证之后触发, 如果返回false, 则值无效\nbeforeValidatebeforeValidate(value, row, prop, [source])\n定义了验证器函数，并在单元格验证之前激发\n\n\n\nParam\nType\nDesc\n\n\n\nisValid\nBoolean\n验证是否通过\n\n\nvalue\n\n\n\n\nrow\nnum\n所在行索引\n\n\nprop\nstring | number\n属性名或者列索引\n\n\n[source]\nstring\n\n\n\n\nafterViewportColumnCalculatorOverrideafterViewportColumnCalculatorOverride(calc)\nafterViewportRowCalculatorOverrideafterViewportRowCalculatorOverride(calc)\nbeforeHighlightingColumnHeaderbeforeHighlightingColumnHeader(column, headerLevel, highlightMeta) ⇒ number | undefined\nbeforeHighlightingRowHeaderbeforeHighlightingRowHeader(row, headerLevel, highlightMeta) ⇒ number | undefined\nbeforeCellAlignmentbeforeCellAlignment(stateBefore, range, type, alignmentClass)\n对齐单元格内容之前触发\nbeforeDrawBordersbeforeDrawBorders(corners, borderClassName)\n绘制边框后触发\nbeforeInitWalkontablebeforeInitWalkontable(walkontableConfig)\nbeforeKeyDownbeforeKeyDown(event)\n键盘事件\nbeforeRemoveCellClassNamesbeforeRemoveCellClassNames ⇒ Array&lt;string&gt; | undefined\n在Walkontable的refreshSelections方法内部激发。可用于删除表中所有单元格的附加类名。\nbeforeSetRangeStartbeforeSetRangeStart(coords)\n在设置范围开始之前触发\nbeforeSetRangeStartOnlybeforeSetRangeStartOnly(coords)\n在设置范围开始但尚未完成之前触发。\nbeforeSetRangeEndbeforeSetRangeEnd(coords)\n在设置范围结束之前触发\nbeforeStretchingColumnWidthbeforeStretchingColumnWidth(stretchedWidth, column) ⇒ number\n在列宽度设置之前触发, 返回值为列宽\nconstruct构造函数\ninit表格实例化之后, 渲染之前\n\nmodifyColHeadermodifyColHeader(column)\n当回调函数将要修改列标题索引时触发\nmodifyColumnHeaderHeightmodifyColumnHeaderHeight\n检索或修改列头高度时触发\nmodifyColWidthmodifyColWidth(width, column)\n当回调函数将要修改列宽时触发\nmodifyCopyableRangemodifyCopyableRange(copyableRanges)\n回调函数修改可复制范围时触发\nmodifyDatamodifyData(row, column, valueHolder, ioMode)\n修改或获取数据时触发\nmodifyGetCellCoordsmodifyGetCellCoords(row, column, topmost)\n用于在使用getCell方法、打开编辑器、从编辑器获取值以及从关闭的编辑器保存值时修改单元格坐标。\nmodifyRowDatamodifyRowData(row)\n获取或者修改行数据时触发\nmodifyRowHeadermodifyRowHeader(row)\n当回调函数将要修改行标题索引时触发\nmodifyRowHeaderWidthmodifyRowHeaderWidth(rowHeaderWidth)\n检索或修改行头宽度时触发\nmodifySourceDatamodifySourceData(row, column, valueHolder, ioMode)\n检索或修改源数据时触发\nmodifyTransformStartmodifyTransformStart(delta)\n当选择的开始被修改时触发\nmodifyTransformEndmodifyTransformEnd(delta)\n当选择的结尾被修改时触发\n\npersistentStateLoadpersistentStateLoad(key, valuePlaceholder)\n当从localStorage加载值, 保存键后由插件(PersistentState)触发, 需在option中开启persistentState选项\npersistentStateResetpersistentStateReset([key])\n当从localStorage重置数据后由插件(PersistentState)触发, 需在option中开启persistentState选项\npersistentStateSavepersistentStateSave(key, value)\n当在localStorage中保存给定键下的值后后由插件(PersistentState)触发,需在option中开启persistentState选项\nMethodsaddadd(hookName, callback)\n对Hook添加监听, 触发回调函数, 可以全局添加, 也可以指定Handsontable实例添加\nimport HandsonTable from 'handsontable';\n// 全局添加一个\nHandsonTable.hooks.add('afterChange', fn1);\n// 指定实例添加一个\nHandsonTable.hooks.add('afterChange', fn1, HandsontableInstance);\n// 全局添加多个\nHandsonTable.hooks.add('afterChange', [fn1, fn2, fn3]);\n// 指定实例添加多个\nHandsonTable.hooks.add('afterChange', [fn1, fn2, fn3], HandsontableInstance);\n\nfunction fn1(a) &#123;console.log('fn1', a)&#125;\nfunction fn2(a) &#123;console.log('fn2', a)&#125;\nfunction fn3(a) &#123;console.log('fn3', a)&#125;\n\n\n\ncreateEmptyBuckethooks.createEmptyBucket() ⇒ object\n返回所有注册的Hook组成的新对象, hook名称作为key, value为[]\ndestroyhooks.destroy([context])\n销毁所有连接到上下文的监听器。如果没有提供上下文，全局监听器将被销毁\ngetBuckethooks.getBucket([context]) ⇒ object\n获取参数中的hook, 如果未传参数, 则获取全部的hook\nregisterhooks.register(key)\n注册一个hook\nderegisterhooks.deregister(key)\n取消一个hook的注册\ngetRegisteredhooks.getRegistered() ⇒ Array\n获取已注册的hook\nisRegisteredhooks.isRegistered(hookName) ⇒ boolean\n判断一个hook是否注册\nhashooks.has(key, [context]) ⇒ boolean\n判断一个hook是否有监听, 第二个参数可以指定Handsontable实例\nisDeprecatedhooks.isDeprecated(hookName) ⇒ boolean\n判断一个hook是否被移除或者弃用\noncehooks.once(key, callback, [context])\n对一个hook只进行一次监听, 第二个参数可以指定Handsontable实例\nremovehooks.remove(key, callback, [context]) ⇒ boolean\n移除一个hook,第二个参数可以指定Handsontable实例\nrunhooks.run(context, key, [p1], [p2], [p3], [p4], [p5], [p6]) ⇒ void\n\n相关链接\n\n  Handsontable之Plugin篇-MergeCells \n  Handsontable之Plugin篇-Autofill  -->\n  Handsontable之Plugin篇-MergeCells  -->\n  Handsontable之core篇  -->\n\n\n\n\n\n","slug":"Handsontable-Hooks","date":"2022-04-15T07:02:57.000Z","categories_index":"","tags_index":"Handsontable","author_index":"王磊磊"},{"id":"7bd034d8c0c4eb1cebe9149a16242bb1","title":"Handsontable-plugin-MergeCells","content":"描述\n插件，允许合并表格中的单元格(使用初始配置、API或上下文菜单)。\n选项\nmergeCellsboolean|Array&lt;object&gt;\n\n\n\nsetting\n描述\n\n\n\ntrue\n开启MergeCells插件\n\n\nfalse\n关闭MergeCells插件\n\n\nAn array of objects\n- 开启插件    - 初始化时合并指定单元格\n\n\n若要在Handsontable初始化时合并特定单元格，请将mergeCells选项设置为一个对象数组\n\n\n\nprop\ndesc\n\n\n\nrow\n合并开始行\n\n\ncol\n合并开始列\n\n\nrowspan\n合并行单元格数量\n\n\ncolspan\n合并列单元格数量\n\n\nMethodsclearCollectionsclearCollections()\n清除合并单元格效果\ndisablePlugindisablePlugin()\n禁用单元格合并\nenablePluginenablePlugin()\n启用单元格合并\nisEnabledisEnabled()\n检查插件是否启用。此方法在Hooks#beforeInit hook中执行，如果返回true，则调用MergeCells#enablePlugin\nmergemerge(startRow, startColumn, endRow, endColumn)\n\n\n\nParam\nType\nDesc\n\n\n\nstartRow\nnum\n开始行\n\n\nstartColumn\nnum\n开始列\n\n\nendRow\nnum\n结束行\n\n\nendColumn\nnum\n结束列\n\n\nEmits: Hooks#event:beforeMergeCells, Hooks#event:afterMergeCells\n合并指定的单元格\nmergeSelectionmergeSelection([cellRange])\n\n\n\nParam\nType\nDesc\n\n\n\n[cellRange]\nCellRange\n选择单元格范围\n\n\n合并作为单元格区域提供的选定内容\nunmergeunmerge(startRow, startColumn, endRow, endColumn)\nEmits: Hooks#event:beforeUnmergeCells, Hooks#event:afterUnmergeCells\n取消合并的单元格,参数同merge\nunmergeSelectionunmergeSelection([cellRange])\n取消合并作为单元格区域提供的选定内容。参数同mergeSelection\nupdatePluginupdatePlugin()\n更新插件状态\n","slug":"Handsontable-plugin-MergeCells","date":"2022-04-15T06:27:39.000Z","categories_index":"","tags_index":"Handsontable","author_index":"王磊磊"}]